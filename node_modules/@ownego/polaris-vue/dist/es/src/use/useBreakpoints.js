import { ref, onBeforeUnmount } from "vue";
import { G as getMediaConditions, u as themeDefault } from "../../vendor.js";
const Breakpoints = {
  // TODO: Update to smDown
  navigationBarCollapsed: "767.95px",
  // TODO: Update to lgDown
  stackedContent: "1039.95px"
};
const noWindowMatches = {
  media: "",
  addListener: noop,
  removeListener: noop,
  matches: false,
  onchange: noop,
  addEventListener: noop,
  removeEventListener: noop,
  dispatchEvent: (_) => true
};
function noop() {
}
function navigationBarCollapsed() {
  return typeof window === "undefined" ? noWindowMatches : window.matchMedia(`(max-width: ${Breakpoints.navigationBarCollapsed})`);
}
function stackedContent() {
  return typeof window === "undefined" ? noWindowMatches : window.matchMedia(`(max-width: ${Breakpoints.stackedContent})`);
}
const breakpointsQueryEntries = getBreakpointsQueryEntries(
  themeDefault.breakpoints
);
function getMatches(defaults, forceDefaults) {
  const isServer = typeof window === "undefined" || typeof document === "undefined";
  if (!isServer && !forceDefaults) {
    return Object.fromEntries(
      breakpointsQueryEntries.map(([directionAlias, query]) => [
        directionAlias,
        window.matchMedia(query).matches
      ])
    );
  }
  if (typeof defaults === "object" && defaults !== null) {
    return Object.fromEntries(
      breakpointsQueryEntries.map(([directionAlias]) => [
        directionAlias,
        defaults[directionAlias] ?? false
      ])
    );
  }
  return Object.fromEntries(
    breakpointsQueryEntries.map(([directionAlias]) => [
      directionAlias,
      defaults ?? false
    ])
  );
}
function useBreakpoints(options) {
  const breakpoints = ref(getMatches(options == null ? void 0 : options.defaults, true));
  const setBreakpoints = (value) => {
    breakpoints.value = value;
  };
  const mediaQueryLists = breakpointsQueryEntries.map(
    ([_, query]) => window.matchMedia(query)
  );
  const handler = () => setBreakpoints(getMatches());
  mediaQueryLists.forEach((mql) => {
    if (mql.addListener) {
      mql.addListener(handler);
    } else {
      mql.addEventListener("change", handler);
    }
  });
  handler();
  onBeforeUnmount(() => {
    mediaQueryLists.forEach((mql) => {
      if (mql.removeListener) {
        mql.removeListener(handler);
      } else {
        mql.removeEventListener("change", handler);
      }
    });
  });
  return breakpoints;
}
function getBreakpointsQueryEntries(breakpoints) {
  const mediaConditionEntries = Object.entries(getMediaConditions(breakpoints));
  return mediaConditionEntries.map(
    ([breakpointsToken, mediaConditions]) => Object.entries(mediaConditions).map(([direction, mediaCondition]) => {
      const breakpointsAlias = breakpointsToken.split("-")[1];
      const directionAlias = `${breakpointsAlias}${capitalize(direction)}`;
      return [directionAlias, mediaCondition];
    })
  ).flat();
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
export {
  navigationBarCollapsed as n,
  stackedContent as s,
  useBreakpoints as u
};
//# sourceMappingURL=useBreakpoints.js.map
