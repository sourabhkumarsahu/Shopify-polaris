{"version":3,"file":"useIsSticky.js","sources":["../../../../src/use/useIsSticky.ts"],"sourcesContent":["import { computed, onMounted, ref, watch, onBeforeUnmount, type Ref } from 'vue';\nimport { debounce } from '@polaris/utilities/debounce';\nimport type { IndexFiltersMode } from '@/components/IndexFilters/types';\n\nconst DEBOUNCE_PERIOD = 250;\n\nexport function useIsSticky(\n  mode: IndexFiltersMode,\n  disabled: boolean,\n  isFlushWhenSticky: boolean,\n) {\n  const hasIOSupport = typeof window !== 'undefined' && Boolean(window.IntersectionObserver);\n\n  const indexFilteringHeight = ref(0);\n  const isSticky = ref(false);\n  const measurerRef = ref<HTMLDivElement | null>(null);\n  const intersectionRef = ref<HTMLDivElement | null>(null);\n\n  const handleIntersect = (entries: IntersectionObserverEntry[]) => {\n     entries.forEach((entry: IntersectionObserverEntry) => {\n      isSticky.value = !entry.isIntersecting;\n    });\n  };\n\n  const options = {\n    root: null,\n    rootMargin: `${isFlushWhenSticky ? '0px' : '-56px'} 0px 0px 0px`,\n    threshold: 0,\n  };\n\n  const observerRef = ref<IntersectionObserver | null>(hasIOSupport ? new IntersectionObserver(handleIntersect, options) : null);\n\n  const box = computed(() => measurerRef.value?.getBoundingClientRect());\n\n  const computeTableDimensions = () => {\n    if (!measurerRef.value) {\n      return {\n        height: 0,\n      };\n    }\n    if (!box.value) {\n      return;\n    }\n\n    const height = box.value.height;\n\n    indexFilteringHeight.value = height;\n  };\n\n  const debouncedComputeDimensions = debounce(\n    computeTableDimensions,\n    DEBOUNCE_PERIOD,\n    {\n      trailing: true,\n    },\n  );\n\n  onMounted(() => {\n    window.addEventListener('resize', debouncedComputeDimensions);\n\n    // Observer\n    if (!observerRef.value) {\n      return;\n    }\n\n    if (intersectionRef.value) {\n      observerRef.value.observe(intersectionRef.value);\n    }\n  });\n\n  onBeforeUnmount(() => {\n    window.removeEventListener('resize', debouncedComputeDimensions);\n\n    observerRef.value?.disconnect();\n  });\n\n  watch(\n    () => mode,\n    () => {\n      computeTableDimensions();\n    },\n    { flush: 'post' },\n  );\n\n  return {\n    intersectionRef: intersectionRef as Ref<HTMLDivElement>,\n    measurerRef,\n    isSticky: isSticky.value && !disabled,\n    indexFilteringHeight,\n  };\n}\n\n"],"names":[],"mappings":";;AAIA,MAAM,kBAAkB;AAER,SAAA,YACd,MACA,UACA,mBACA;AACA,QAAM,eAAe,OAAO,WAAW,eAAe,QAAQ,OAAO,oBAAoB;AAEnF,QAAA,uBAAuB,IAAI,CAAC;AAC5B,QAAA,WAAW,IAAI,KAAK;AACpB,QAAA,cAAc,IAA2B,IAAI;AAC7C,QAAA,kBAAkB,IAA2B,IAAI;AAEjD,QAAA,kBAAkB,CAAC,YAAyC;AACvD,YAAA,QAAQ,CAAC,UAAqC;AAC5C,eAAA,QAAQ,CAAC,MAAM;AAAA,IAAA,CACzB;AAAA,EAAA;AAGH,QAAM,UAAU;AAAA,IACd,MAAM;AAAA,IACN,YAAY,GAAG,oBAAoB,QAAQ,OAAO;AAAA,IAClD,WAAW;AAAA,EAAA;AAGP,QAAA,cAAc,IAAiC,eAAe,IAAI,qBAAqB,iBAAiB,OAAO,IAAI,IAAI;AAE7H,QAAM,MAAM,SAAS,MAAA;;AAAM,6BAAY,UAAZ,mBAAmB;AAAA,GAAuB;AAErE,QAAM,yBAAyB,MAAM;AAC/B,QAAA,CAAC,YAAY,OAAO;AACf,aAAA;AAAA,QACL,QAAQ;AAAA,MAAA;AAAA,IAEZ;AACI,QAAA,CAAC,IAAI,OAAO;AACd;AAAA,IACF;AAEM,UAAA,SAAS,IAAI,MAAM;AAEzB,yBAAqB,QAAQ;AAAA,EAAA;AAG/B,QAAM,6BAA6B;AAAA,IACjC;AAAA,IACA;AAAA,IACA;AAAA,MACE,UAAU;AAAA,IACZ;AAAA,EAAA;AAGF,YAAU,MAAM;AACP,WAAA,iBAAiB,UAAU,0BAA0B;AAGxD,QAAA,CAAC,YAAY,OAAO;AACtB;AAAA,IACF;AAEA,QAAI,gBAAgB,OAAO;AACb,kBAAA,MAAM,QAAQ,gBAAgB,KAAK;AAAA,IACjD;AAAA,EAAA,CACD;AAED,kBAAgB,MAAM;;AACb,WAAA,oBAAoB,UAAU,0BAA0B;AAE/D,sBAAY,UAAZ,mBAAmB;AAAA,EAAW,CAC/B;AAED;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AACmB;IACzB;AAAA,IACA,EAAE,OAAO,OAAO;AAAA,EAAA;AAGX,SAAA;AAAA,IACL;AAAA,IACA;AAAA,IACA,UAAU,SAAS,SAAS,CAAC;AAAA,IAC7B;AAAA,EAAA;AAEJ;"}