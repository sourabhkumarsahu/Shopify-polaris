{"version":3,"file":"useLegacyCard.js","sources":["../../../../src/use/useLegacyCard.ts"],"sourcesContent":["import { ref, onMounted } from 'vue';\nimport styles from '@polaris/components/LegacyCard/LegacyCard.module.css';\n\nexport function useLegacyCardPaddingObserverRef() {\n  const legacyCard = ref<HTMLDivElement | null>(null);\n\n  onMounted(() => {\n    const legacyCardNode = legacyCard.value;\n    let firstSection: Element | undefined;\n    let lastSection: Element | undefined;\n\n    if (legacyCardNode) {\n      const updateFirstAndLastSectionPadding = () => {\n        // Reset old first and last section padding\n        updatePadding(firstSection, 'top', false);\n        updatePadding(lastSection, 'bottom', false);\n\n        // Get current first and last sections, return if they don't exist\n        const currentElements = legacyCardNode.querySelectorAll(\n          `.${styles.Section}, .${styles.Header}, .${styles.Footer}`,\n        );\n        if (!currentElements?.length) return;\n\n        const firstElement = currentElements[0];\n        const lastElement = currentElements[currentElements.length -1];\n\n        // Update padding for first element if it is the first child or\n        // a descendant of the first child\n        if (legacyCardNode.firstElementChild?.contains(firstElement)) {\n          firstSection = firstElement;\n          updatePadding(firstSection, 'top', true);\n        }\n\n        // Update padding for last element if it is the last child or\n        // a descendant of the last child\n        if (legacyCardNode.lastElementChild?.contains(lastElement)) {\n          lastSection = lastElement;\n          updatePadding(lastSection, 'bottom', true);\n        }\n      };\n\n      // First initial render\n      updateFirstAndLastSectionPadding();\n\n      // Re-run when descendants are changed\n      const observer = new MutationObserver(updateFirstAndLastSectionPadding);\n      observer.observe(legacyCardNode, {\n        childList: true,\n        subtree: true,\n      });\n\n      return () => {\n        // Clean up by removing added classes\n        updatePadding(firstSection, 'top', false);\n        updatePadding(lastSection, 'bottom', false);\n        observer.disconnect();\n      };\n    }\n  });\n\n  return legacyCard;\n}\n\nfunction updatePadding(\n  element: Element | undefined,\n  area: 'top' | 'bottom',\n  add: boolean,\n) {\n  if (!element || element.className.includes(styles['Section-flush'])) return;\n\n  switch (area) {\n    case 'top':\n      (element as HTMLElement).classList.toggle(\n        styles.FirstSectionPadding,\n        add,\n      );\n      return;\n    case 'bottom':\n      (element as HTMLElement).classList.toggle(\n        styles.LastSectionPadding, add\n      );\n  }\n}\n"],"names":[],"mappings":";;AAGO,SAAS,kCAAkC;AAC1C,QAAA,aAAa,IAA2B,IAAI;AAElD,YAAU,MAAM;AACd,UAAM,iBAAiB,WAAW;AAC9B,QAAA;AACA,QAAA;AAEJ,QAAI,gBAAgB;AAClB,YAAM,mCAAmC,MAAM;;AAE/B,sBAAA,cAAc,OAAO,KAAK;AAC1B,sBAAA,aAAa,UAAU,KAAK;AAG1C,cAAM,kBAAkB,eAAe;AAAA,UACrC,IAAI,OAAO,OAAO,MAAM,OAAO,MAAM,MAAM,OAAO,MAAM;AAAA,QAAA;AAEtD,YAAA,EAAC,mDAAiB,QAAQ;AAExB,cAAA,eAAe,gBAAgB,CAAC;AACtC,cAAM,cAAc,gBAAgB,gBAAgB,SAAQ,CAAC;AAI7D,aAAI,oBAAe,sBAAf,mBAAkC,SAAS,eAAe;AAC7C,yBAAA;AACD,wBAAA,cAAc,OAAO,IAAI;AAAA,QACzC;AAIA,aAAI,oBAAe,qBAAf,mBAAiC,SAAS,cAAc;AAC5C,wBAAA;AACA,wBAAA,aAAa,UAAU,IAAI;AAAA,QAC3C;AAAA,MAAA;AAI+B;AAG3B,YAAA,WAAW,IAAI,iBAAiB,gCAAgC;AACtE,eAAS,QAAQ,gBAAgB;AAAA,QAC/B,WAAW;AAAA,QACX,SAAS;AAAA,MAAA,CACV;AAED,aAAO,MAAM;AAEG,sBAAA,cAAc,OAAO,KAAK;AAC1B,sBAAA,aAAa,UAAU,KAAK;AAC1C,iBAAS,WAAW;AAAA,MAAA;AAAA,IAExB;AAAA,EAAA,CACD;AAEM,SAAA;AACT;AAEA,SAAS,cACP,SACA,MACA,KACA;AACI,MAAA,CAAC,WAAW,QAAQ,UAAU,SAAS,OAAO,eAAe,CAAC,EAAG;AAErE,UAAQ,MAAM;AAAA,IACZ,KAAK;AACF,cAAwB,UAAU;AAAA,QACjC,OAAO;AAAA,QACP;AAAA,MAAA;AAEF;AAAA,IACF,KAAK;AACF,cAAwB,UAAU;AAAA,QACjC,OAAO;AAAA,QAAoB;AAAA,MAAA;AAAA,EAEjC;AACF;"}