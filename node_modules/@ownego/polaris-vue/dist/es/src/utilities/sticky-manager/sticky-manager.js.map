{"version":3,"file":"sticky-manager.js","sources":["../../../../../src/utilities/sticky-manager/sticky-manager.ts"],"sourcesContent":["import { themeDefault } from '@shopify/polaris-tokens';\n\nimport { debounce } from '@polaris/utilities/debounce';\nimport { dataPolarisTopBar, scrollable } from '@polaris/components/shared';\nimport { stackedContent } from '@/use/useBreakpoints';\nimport type { Rect } from '../geometry';\nimport { getRectForNode } from '../geometry';\n\ninterface StickyItem {\n  /** Node of the sticky element */\n  stickyNode: HTMLElement;\n  /** Placeholder element */\n  placeHolderNode: HTMLElement;\n  /** Element outlining the fixed position boundaries */\n  boundingElement?: HTMLElement | null;\n  /** Offset vertical spacing from the top of the scrollable container */\n  offset: boolean;\n  /** Should the element remain in a fixed position when the layout is stacked (smaller screens)  */\n  disableWhenStacked: boolean;\n  /** Method to handle positioning */\n  handlePositioning(\n    stick: boolean,\n    top?: number,\n    left?: number,\n    width?: string | number,\n  ): void;\n}\n\nconst SIXTY_FPS = 1000 / 60;\n\nexport class StickyManager {\n  private stickyItems: StickyItem[] = [];\n  private stuckItems: StickyItem[] = [];\n  private container: Document | HTMLElement | null = null;\n  private topBarOffset = 0;\n\n  private handleResize = debounce(\n    () => {\n      this.manageStickyItems();\n    },\n    SIXTY_FPS,\n    {leading: true, trailing: true, maxWait: SIXTY_FPS},\n  );\n\n  private handleScroll = debounce(\n    () => {\n      this.manageStickyItems();\n    },\n    SIXTY_FPS,\n    {leading: true, trailing: true, maxWait: SIXTY_FPS},\n  );\n\n  constructor(container?: Document | HTMLElement) {\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  registerStickyItem(stickyItem: StickyItem): void {\n    this.stickyItems.push(stickyItem);\n  }\n\n  unregisterStickyItem(nodeToRemove: HTMLElement) {\n    const nodeIndex = this.stickyItems.findIndex(\n      ({stickyNode}) => nodeToRemove === stickyNode,\n    );\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n\n  getStickyItem(node: HTMLElement) {\n    return this.stickyItems.find(({stickyNode}) => node === stickyNode);\n  }\n\n  setContainer(el: Document | HTMLElement) {\n    this.container = el;\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n\n  private manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = this.container\n      ? getRectForNode(this.container).top + this.topBarOffset\n      : 0;\n\n    this.stickyItems.forEach((stickyItem) => {\n      const {handlePositioning} = stickyItem;\n\n      const {sticky, top, left, width} = this.evaluateStickyItem(\n        stickyItem,\n        scrollTop,\n        containerTop,\n      );\n\n      this.updateStuckItems(stickyItem, sticky);\n\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n\n  private evaluateStickyItem(\n    stickyItem: StickyItem,\n    scrollTop: number,\n    containerTop: number,\n  ): {\n    sticky: boolean;\n    top: number;\n    left: number;\n    width: string | number;\n  } {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked,\n    } = stickyItem;\n\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto',\n      };\n    }\n\n    const stickyOffset = offset\n      ? this.getOffset(stickyNode) +\n        parseInt(\n          // Important: This will not update when the active theme changes.\n          // Update this to `useTheme` once converted to a function component.\n          themeDefault.space['space-500'],\n          10,\n        )\n      : this.getOffset(stickyNode);\n\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop =\n      placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n\n    let sticky: boolean;\n\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      const stickyItemHeight =\n        stickyNode.getBoundingClientRect().height ||\n        stickyNode.firstElementChild?.getBoundingClientRect().height ||\n        0;\n      const stickyItemBottomPosition =\n        boundingElement.getBoundingClientRect().bottom -\n        stickyItemHeight +\n        scrollTop -\n        containerTop;\n\n      sticky =\n        scrollPosition >= placeHolderNodeCurrentTop &&\n        scrollPosition < stickyItemBottomPosition;\n    }\n\n    return {\n      sticky,\n      top,\n      left,\n      width,\n    };\n  }\n\n  private updateStuckItems(item: StickyItem, sticky: boolean) {\n    const {stickyNode} = item;\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n\n  private addStuckItem(stickyItem: StickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n\n  private removeStuckItem(stickyItem: StickyItem) {\n    const {stickyNode: nodeToRemove} = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(\n      ({stickyNode}) => nodeToRemove === stickyNode,\n    );\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n\n  private getOffset(node: HTMLElement) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n      count++;\n    }\n\n    return offset;\n  }\n\n  private isNodeStuck(node: HTMLElement): boolean {\n    const nodeFound = this.stuckItems.findIndex(\n      ({stickyNode}) => node === stickyNode,\n    );\n\n    return nodeFound >= 0;\n  }\n\n  private setTopBarOffset(container: Document) {\n    const topbarElement = container.querySelector(\n      `:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`,\n    );\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n}\n\nfunction isDocument(node: HTMLElement | Document): node is Document {\n  return node === document;\n}\n\nfunction scrollTopFor(container: HTMLElement | Document) {\n  return isDocument(container)\n    ? document.body.scrollTop || document.documentElement.scrollTop\n    : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1: Rect, rect2: Rect) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n"],"names":[],"mappings":"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"}