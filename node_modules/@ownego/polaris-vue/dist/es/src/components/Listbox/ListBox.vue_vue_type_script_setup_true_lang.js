import { defineComponent, useSlots, ref, computed, onUpdated, onMounted, watch, provide, openBlock, createElementBlock, Fragment, unref, createVNode, createCommentVNode, withCtx, createElementVNode, toDisplayString, normalizeClass, renderSlot } from "vue";
import { c as classNames } from "../../utilities/css.js";
import { K as Key } from "../../utilities/types.js";
import { d as debounce } from "../../../polaris/polaris-react/src/utilities/debounce.js";
import { s as scrollable } from "../../../polaris/polaris-react/src/components/shared.js";
import { u as useId } from "../../use/useId.js";
import { A as AutoSelection } from "./utils.js";
import { a as useComboboxListbox } from "../../use/useListbox.js";
import { _ as _sfc_main$1 } from "../KeypressListener/KeypressListener.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$2 } from "../Text/Text.vue_vue_type_script_setup_true_lang.js";
import { s as scrollOptionIntoView } from "../../../polaris/polaris-react/src/utilities/listbox/utilities.js";
const Listbox = "Polaris-Listbox";
const styles = {
  Listbox
};
const _hoisted_1 = { "aria-live": "polite" };
const _hoisted_2 = ["aria-label", "aria-labelledby", "aria-busy", "aria-activedescendant", "id"];
const OPTION_SELECTOR = "[data-listbox-option]";
const OPTION_VALUE_ATTRIBUTE = "data-listbox-option-value";
const OPTION_ACTION_ATTRIBUTE = "data-listbox-option-action";
const OPTION_FOCUS_ATTRIBUTE = "data-focused";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "ListBox",
  props: {
    autoSelection: { default: AutoSelection.FirstSelected },
    enableKeyboardControl: { type: Boolean },
    accessibilityLabel: {},
    customListId: {}
  },
  emits: ["select", "active-option-change"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const comboboxListboxContext = useComboboxListbox();
    const {
      listboxId,
      textFieldLabelId,
      textFieldFocused,
      willLoadMoreOptions,
      setActiveOptionId,
      setListboxId,
      onOptionSelected,
      onKeyToBottom
    } = comboboxListboxContext;
    const listboxRef = ref(null);
    const scrollableRef = ref(null);
    const loading = ref("");
    const lazyLoading = ref(false);
    const currentOptions = ref([]);
    const keyboardEventsEnabled = ref(Boolean(props.enableKeyboardControl));
    const activeOption = ref();
    const uniqueId = String(useId());
    const listId = computed(() => props.customListId || uniqueId);
    const inCombobox = computed(() => Boolean(setActiveOptionId));
    const activeDescendant = computed(() => {
      var _a;
      return (_a = activeOption.value) == null ? void 0 : _a.domId;
    });
    const getNavigableOptions = () => {
      if (!listboxRef.value) {
        return [];
      }
      return [
        ...new Set(
          listboxRef.value.querySelectorAll(OPTION_SELECTOR)
        )
      ];
    };
    const getFirstNavigableOption = (currentOpts) => {
      const hasSelectedOptions = currentOpts.some(
        (option) => option.getAttribute("aria-selected") === "true"
      );
      let elementIndex = 0;
      const element = currentOpts.find((option, index) => {
        const isInteractable = option.getAttribute("aria-disabled") !== "true";
        let isFirstNavigableOption;
        if (hasSelectedOptions && props.autoSelection === AutoSelection.FirstSelected) {
          const isSelected = option.getAttribute("aria-selected") === "true";
          isFirstNavigableOption = isSelected && isInteractable;
        } else {
          isFirstNavigableOption = isInteractable;
        }
        if (isFirstNavigableOption) {
          elementIndex = index;
        }
        return isFirstNavigableOption;
      });
      if (!element) {
        return;
      }
      return { element, index: elementIndex };
    };
    const handleScrollIntoView = (option) => {
      if (scrollableRef.value) {
        scrollOptionIntoView(option.element, scrollableRef.value);
      }
    };
    const handleScrollIntoViewDebounced = debounce(handleScrollIntoView, 50);
    const handleKeyToBottom = () => {
      if (onKeyToBottom) {
        lazyLoading.value = true;
        return Promise.resolve(onKeyToBottom());
      }
    };
    const handleChangeActiveOption = (nextOption) => {
      var _a;
      if (!nextOption) {
        activeOption.value = void 0;
        return;
      }
      (_a = activeOption.value) == null ? void 0 : _a.element.removeAttribute(OPTION_FOCUS_ATTRIBUTE);
      nextOption == null ? void 0 : nextOption.element.setAttribute(OPTION_FOCUS_ATTRIBUTE, "true");
      handleScrollIntoViewDebounced(nextOption);
      activeOption.value = nextOption;
      setActiveOptionId == null ? void 0 : setActiveOptionId(nextOption.domId);
      emits("active-option-change", nextOption.value);
    };
    const getFormattedOption = (element, index) => {
      return {
        element,
        index,
        domId: element.id,
        value: element.getAttribute(OPTION_VALUE_ATTRIBUTE) || "",
        disabled: element.getAttribute("aria-disabled") === "true",
        isAction: element.getAttribute(OPTION_ACTION_ATTRIBUTE) === "true"
      };
    };
    const resetActiveOption = () => {
      var _a, _b;
      let nextOption;
      const nextOptions = getNavigableOptions();
      const nextActiveOption = getFirstNavigableOption(nextOptions);
      if (nextOptions.length === 0 && currentOptions.value.length > 0) {
        currentOptions.value = nextOptions;
        handleChangeActiveOption();
        return;
      }
      if (nextActiveOption) {
        const { element, index } = nextActiveOption;
        nextOption = getFormattedOption(element, index);
      }
      const optionIsAlreadyActive = activeOption.value !== void 0 && (nextOption == null ? void 0 : nextOption.domId) === ((_a = activeOption.value) == null ? void 0 : _a.domId);
      const actionContentHasUpdated = ((_b = activeOption.value) == null ? void 0 : _b.isAction) && (nextOption == null ? void 0 : nextOption.isAction) && (nextOption == null ? void 0 : nextOption.value) !== (activeOption == null ? void 0 : activeOption.value);
      const currentValues = currentOptions.value.map(
        (option) => option.getAttribute(OPTION_VALUE_ATTRIBUTE)
      );
      const nextValues = nextOptions.map(
        (option) => option.getAttribute(OPTION_VALUE_ATTRIBUTE)
      );
      const listIsUnchanged = nextValues.length === currentValues.length && nextValues.every((value, index) => {
        return currentValues[index] === value;
      });
      if (listIsUnchanged) {
        if (optionIsAlreadyActive && actionContentHasUpdated) {
          currentOptions.value = nextOptions;
          handleChangeActiveOption(nextOption);
        }
        return;
      }
      const listIsAppended = currentValues.length !== 0 && nextValues.length > currentValues.length && currentValues.every((value, index) => {
        return nextValues[index] === value;
      });
      if (listIsAppended) {
        currentOptions.value = nextOptions;
        return;
      }
      currentOptions.value = nextOptions;
      if (lazyLoading.value) {
        lazyLoading.value = false;
        return;
      }
      handleChangeActiveOption(nextOption);
    };
    const getNextValidOption = async (key) => {
      var _a, _b;
      const lastIndex = currentOptions.value.length - 1;
      let currentIndex = ((_a = activeOption.value) == null ? void 0 : _a.index) || 0;
      let nextIndex = 0;
      let element = (_b = activeOption.value) == null ? void 0 : _b.element;
      let totalOptions = -1;
      if (!activeOption.value && props.autoSelection === AutoSelection.None) {
        const nextOptions = getNavigableOptions();
        const nextActiveOption = getFirstNavigableOption(nextOptions);
        currentOptions.value = nextOptions;
        const {
          element: tmpElement,
          index
        } = nextActiveOption;
        return {
          element: tmpElement,
          nextIndex: index || 0
        };
      }
      while (totalOptions++ < lastIndex) {
        nextIndex = getNextIndex(currentIndex, lastIndex, key);
        element = currentOptions.value[nextIndex];
        const triggerLazyLoad = nextIndex >= lastIndex;
        const isDisabled = (element == null ? void 0 : element.getAttribute("aria-disabled")) === "true";
        if (triggerLazyLoad && (willLoadMoreOptions == null ? void 0 : willLoadMoreOptions.value)) {
          await handleKeyToBottom();
        }
        if (isDisabled) {
          currentIndex = nextIndex;
          element = void 0;
          continue;
        }
        break;
      }
      return { element, nextIndex };
    };
    const handleArrow = async (type, event) => {
      event.preventDefault();
      const { element, nextIndex } = await getNextValidOption(type);
      if (!element) {
        return;
      }
      const nextOption = getFormattedOption(element, nextIndex);
      handleChangeActiveOption(nextOption);
    };
    const handleDownArrow = (event) => {
      handleArrow("down", event);
    };
    const handleUpArrow = (event) => {
      handleArrow("up", event);
    };
    const handleEnter = (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (activeOption.value) {
        onOptionSelect(activeOption.value);
      }
    };
    const handleFocus = () => {
      if (props.enableKeyboardControl) {
        return;
      }
      keyboardEventsEnabled.value = true;
    };
    const handleBlur = (event) => {
      event.stopPropagation();
      if (keyboardEventsEnabled.value) {
        const nextActiveOption = getFirstNavigableOption(currentOptions.value);
        if (nextActiveOption) {
          const { element, index } = nextActiveOption;
          const nextOption = getFormattedOption(element, index);
          handleChangeActiveOption(nextOption);
        }
      }
      if (props.enableKeyboardControl) {
        return;
      }
      keyboardEventsEnabled.value = false;
    };
    const setLoading = (value) => {
      loading.value = value;
    };
    const getNextIndex = (currentIndex, lastIndex, direction) => {
      let nextIndex;
      if (direction === "down") {
        if (currentIndex === lastIndex) {
          nextIndex = (willLoadMoreOptions == null ? void 0 : willLoadMoreOptions.value) ? currentIndex + 1 : 0;
        } else {
          nextIndex = currentIndex + 1;
        }
      } else {
        nextIndex = currentIndex === 0 ? lastIndex : currentIndex - 1;
      }
      return nextIndex;
    };
    const onOptionSelect = (option) => {
      handleChangeActiveOption(option);
      if (onOptionSelected) {
        onOptionSelected();
      }
      emits("select", option.value);
    };
    onUpdated(() => {
      if (props.autoSelection !== AutoSelection.None && !loading.value && slots.default && slots.default().length > 0) {
        resetActiveOption();
      }
    });
    onMounted(() => {
      if (props.autoSelection !== AutoSelection.None && !loading.value && slots.default && slots.default().length > 0) {
        resetActiveOption();
      }
      if (props.enableKeyboardControl && !keyboardEventsEnabled.value) {
        keyboardEventsEnabled.value = true;
      }
      if (setListboxId && !(listboxId == null ? void 0 : listboxId.value)) {
        setListboxId(listId.value);
      }
    });
    watch(
      () => listboxRef.value,
      () => {
        if (listboxRef.value) {
          scrollableRef.value = listboxRef.value.closest(scrollable.selector);
        }
      }
    );
    provide("listbox", { onOptionSelect, setLoading });
    provide("within-listbox", true);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        keyboardEventsEnabled.value || unref(textFieldFocused) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createVNode(unref(_sfc_main$1), {
            keyEvent: "keydown",
            keyCode: unref(Key).DownArrow,
            handler: handleDownArrow
          }, null, 8, ["keyCode"]),
          createVNode(unref(_sfc_main$1), {
            keyEvent: "keydown",
            keyCode: unref(Key).UpArrow,
            handler: handleUpArrow
          }, null, 8, ["keyCode"]),
          createVNode(unref(_sfc_main$1), {
            keyEvent: "keydown",
            keyCode: unref(Key).Enter,
            handler: handleEnter
          }, null, 8, ["keyCode"])
        ], 64)) : createCommentVNode("", true),
        createVNode(unref(_sfc_main$2), {
          as: "span",
          "visually-hidden": ""
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_1, toDisplayString(loading.value ? loading.value : null), 1)
          ]),
          _: 1
        }),
        slots.default ? (openBlock(), createElementBlock("ul", {
          key: 1,
          tabindex: "0",
          role: "listbox",
          class: normalizeClass(unref(classNames)(unref(styles).Listbox)),
          "aria-label": inCombobox.value ? void 0 : _ctx.accessibilityLabel,
          "aria-labelledby": unref(textFieldLabelId) || void 0,
          "aria-busy": Boolean(loading.value),
          "aria-activedescendant": activeDescendant.value,
          id: listId.value,
          onFocus: handleFocus,
          onBlur: handleBlur,
          ref_key: "listboxRef",
          ref: listboxRef
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 42, _hoisted_2)) : createCommentVNode("", true)
      ], 64);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=ListBox.vue_vue_type_script_setup_true_lang.js.map
