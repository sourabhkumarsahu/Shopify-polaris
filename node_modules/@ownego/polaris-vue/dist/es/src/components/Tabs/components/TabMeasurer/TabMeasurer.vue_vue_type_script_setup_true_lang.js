import { defineComponent, useSlots, ref, computed, onMounted, openBlock, createElementBlock, normalizeClass, Fragment, renderList, createBlock, unref, renderSlot } from "vue";
import { c as classNames } from "../../../../utilities/css.js";
import { u as useEventListener } from "../../../../utilities/use-event-listener.js";
import { s as styles } from "../../Tabs.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$1 } from "../Tab/Tab.vue_vue_type_script_setup_true_lang.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "TabMeasurer",
  props: {
    tabToFocus: {},
    siblingTabHasFocus: { type: Boolean },
    selected: {},
    tabs: {}
  },
  emits: ["measurement"],
  setup(__props, { emit: __emit }) {
    useSlots();
    const emits = __emit;
    const containerNode = ref(null);
    const animationFrame = ref(null);
    const classname = computed(() => classNames(styles.Tabs, styles.TabsMeasurer));
    const handleMeasurement = () => {
      if (animationFrame.value) {
        cancelAnimationFrame(animationFrame.value);
      }
      animationFrame.value = requestAnimationFrame(() => {
        if (!containerNode.value) {
          return;
        }
        const containerWidth = containerNode.value.offsetWidth - 20 - 28;
        const hiddenTabNodes = containerNode.value.children;
        const hiddenTabNodesArray = Array.from(hiddenTabNodes);
        const hiddenTabWidths = hiddenTabNodesArray.map((node) => {
          const buttonWidth = Math.ceil(node.getBoundingClientRect().width);
          return buttonWidth + 4;
        });
        const disclosureWidth = hiddenTabWidths.pop() || 0;
        emits("measurement", {
          containerWidth,
          disclosureWidth,
          hiddenTabWidths
        });
      });
    };
    onMounted(() => {
      handleMeasurement();
    });
    useEventListener("resize", handleMeasurement);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(classname.value),
        ref_key: "containerNode",
        ref: containerNode
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.tabs, (tab, index) => {
          return openBlock(), createBlock(unref(_sfc_main$1), {
            measuring: true,
            key: `${tab.id}Hidden`,
            id: `${tab.id}`,
            siblingTabHasFocus: _ctx.siblingTabHasFocus,
            focused: index === _ctx.tabToFocus,
            selected: index === _ctx.selected,
            url: tab.url,
            content: tab.content
          }, null, 8, ["id", "siblingTabHasFocus", "focused", "selected", "url", "content"]);
        }), 128)),
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=TabMeasurer.vue_vue_type_script_setup_true_lang.js.map
