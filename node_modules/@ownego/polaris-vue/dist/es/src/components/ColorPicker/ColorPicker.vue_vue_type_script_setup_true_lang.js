import { defineComponent, mergeModels, useModel, reactive, ref, computed, onMounted, onBeforeUnmount, openBlock, createElementBlock, normalizeClass, unref, createElementVNode, normalizeStyle, createVNode, createBlock, createCommentVNode } from "vue";
import { d as debounce } from "../../../polaris/polaris-react/src/utilities/debounce.js";
import { c as clamp } from "../../../polaris/polaris-react/src/utilities/clamp.js";
import { c as classNames } from "../../utilities/css.js";
import { h as hsbToHex, a as hsbToRgb, b as hexToRgb, r as rgbToHsb } from "../../utilities/color-transformers.js";
import { _ as _sfc_main$3 } from "./components/AlphaPicker/AlphaPicker.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$2 } from "./components/HuePicker/HuePicker.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$1 } from "./components/Slidable/Slidable.vue_vue_type_script_setup_true_lang.js";
const ColorPicker = "Polaris-ColorPicker";
const MainColor = "Polaris-ColorPicker__MainColor";
const fullWidth = "Polaris-ColorPicker--fullWidth";
const Dragger = "Polaris-ColorPicker__Dragger";
const ColorLayer = "Polaris-ColorPicker__ColorLayer";
const HuePicker = "Polaris-ColorPicker__HuePicker";
const AlphaPicker = "Polaris-ColorPicker__AlphaPicker";
const Slidable = "Polaris-ColorPicker__Slidable";
const styles = {
  ColorPicker,
  MainColor,
  fullWidth,
  Dragger,
  ColorLayer,
  HuePicker,
  AlphaPicker,
  Slidable
};
const _hoisted_1 = ["id"];
const RESIZE_DEBOUNCE_TIME_MS = 200;
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "ColorPicker",
  props: /* @__PURE__ */ mergeModels({
    id: {},
    allowAlpha: { type: Boolean },
    fullWidth: { type: Boolean },
    output: {}
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["change"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const model = useModel(__props, "modelValue");
    const pickerSize = reactive({ width: 0, height: 0 });
    const colorHsb = reactive({
      hue: 0,
      saturation: 0,
      brightness: 0,
      alpha: 1
    });
    const colorNode = ref(null);
    const observer = ref(null);
    const huePickerRef = ref(null);
    const draggerX = computed(() => clamp(colorHsb.saturation * pickerSize.width, 0, pickerSize.width));
    const draggerY = computed(() => clamp(pickerSize.height - colorHsb.brightness * pickerSize.height, 0, pickerSize.height));
    const alpha = computed(() => {
      return colorHsb.alpha !== void 0 && props.allowAlpha ? colorHsb.alpha : 1;
    });
    const outputColor = computed(() => {
      if (props.output === "hex") {
        return hsbToHex(colorHsb);
      }
      if (props.output === "rgb") {
        const rgbColor = hsbToRgb(colorHsb);
        return `rgba(${rgbColor.red}, ${rgbColor.green}, ${rgbColor.blue}, ${alpha.value})`;
      }
      return colorHsb;
    });
    const className = classNames(
      styles.ColorPicker,
      props.fullWidth && styles.fullWidth
    );
    const colorString = computed(() => {
      const { red, green, blue } = hsbToRgb({
        hue: colorHsb.hue,
        saturation: 1,
        brightness: 1
      });
      return `rgba(${red}, ${green}, ${blue}, ${alpha.value})`;
    });
    if (typeof model.value === "object") {
      colorHsb.alpha = model.value.alpha || 1;
      colorHsb.hue = model.value.hue;
      colorHsb.saturation = model.value.saturation;
      colorHsb.brightness = model.value.brightness;
    }
    if (typeof model.value === "string") {
      let colorRgb;
      if (/#[0-9abcdef]{3,6}/.test(model.value)) {
        colorRgb = { ...hexToRgb(model.value), alpha: 1 };
      } else {
        const colorRgbArr = model.value.replace(/^rgba?\(|\s+|\)$/g, "").split(",");
        colorRgb = {
          red: parseInt(colorRgbArr[0], 10),
          green: parseInt(colorRgbArr[1], 10),
          blue: parseInt(colorRgbArr[2], 10),
          alpha: parseFloat(colorRgbArr[3]) ? parseFloat(colorRgbArr[3]) : 1
        };
      }
      Object.assign(colorHsb, { ...rgbToHsb(colorRgb), alpha: colorRgb.alpha });
    }
    onMounted(() => {
      if (!colorNode.value) {
        return;
      }
      observer.value = new ResizeObserver(handleResize);
      observer.value.observe(colorNode.value);
      pickerSize.width = colorNode.value.clientWidth;
      pickerSize.height = colorNode.value.clientHeight;
    });
    const handleResize = debounce(() => {
      if (!colorNode.value) {
        return;
      }
      pickerSize.width = colorNode.value.clientWidth;
      pickerSize.height = colorNode.value.clientHeight;
    }, RESIZE_DEBOUNCE_TIME_MS, { leading: true, trailing: true, maxWait: RESIZE_DEBOUNCE_TIME_MS });
    onBeforeUnmount(() => {
      var _a;
      (_a = observer.value) == null ? void 0 : _a.disconnect();
    });
    const handleHueChange = (hue) => {
      colorHsb.hue = hue;
      model.value = outputColor.value;
      emits("change", outputColor.value);
    };
    const handleAlphaChange = (alpha2) => {
      colorHsb.alpha = alpha2;
      model.value = outputColor.value;
      emits("change", outputColor.value);
    };
    const handleDraggerMove = ({ x, y }) => {
      colorHsb.saturation = clamp(x / pickerSize.width, 0, 1);
      colorHsb.brightness = clamp(1 - y / pickerSize.height, 0, 1);
      model.value = outputColor.value;
      emits("change", outputColor.value);
    };
    const handlePickerDrag = (e) => {
      e.preventDefault();
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(className)),
        id: _ctx.id,
        onMousedown: handlePickerDrag
      }, [
        createElementVNode("div", {
          ref_key: "colorNode",
          ref: colorNode,
          class: normalizeClass(unref(styles).MainColor)
        }, [
          createElementVNode("div", {
            class: normalizeClass(unref(styles).ColorLayer),
            style: normalizeStyle({ backgroundColor: colorString.value })
          }, null, 6),
          createVNode(unref(_sfc_main$1), {
            draggerX: draggerX.value,
            draggerY: draggerY.value,
            onChange: handleDraggerMove
          }, null, 8, ["draggerX", "draggerY"])
        ], 2),
        createVNode(unref(_sfc_main$2), {
          ref_key: "huePickerRef",
          ref: huePickerRef,
          hue: colorHsb.hue,
          onChange: handleHueChange
        }, null, 8, ["hue"]),
        _ctx.allowAlpha ? (openBlock(), createBlock(unref(_sfc_main$3), {
          key: 0,
          alpha: alpha.value,
          color: colorHsb,
          onChange: handleAlphaChange
        }, null, 8, ["alpha", "color"])) : createCommentVNode("", true)
      ], 42, _hoisted_1);
    };
  }
});
export {
  _sfc_main as _,
  styles as s
};
//# sourceMappingURL=ColorPicker.vue_vue_type_script_setup_true_lang.js.map
