import { defineComponent, mergeModels, useSlots, useModel, computed, watch, openBlock, createBlock, unref, mergeProps, createSlots, withCtx, renderSlot, createElementBlock, Fragment, createTextVNode, toDisplayString } from "vue";
import { l as labelId } from "../../../Label/utils.js";
import { u as useHasSlot } from "../../../../use/useHasSlot.js";
import { u as useId } from "../../../../use/useId.js";
import { u as useComboboxTextField } from "../../context.js";
import { _ as _sfc_main$1 } from "../../../TextField/TextField.vue_vue_type_script_setup_true_lang.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "TextField",
  props: /* @__PURE__ */ mergeModels({
    prefix: {},
    suffix: {},
    verticalContent: {},
    placeholder: {},
    value: {},
    helpText: {},
    label: {},
    labelAction: {},
    labelHidden: { type: Boolean },
    disabled: { type: Boolean },
    clearButton: { type: Boolean },
    selectTextOnFocus: { type: Boolean },
    suggestion: {},
    readOnly: { type: Boolean },
    autoFocus: { type: Boolean },
    focused: { type: Boolean },
    multiline: { type: [Boolean, Number] },
    error: { type: [String, Array, Boolean] },
    type: { default: "text" },
    name: {},
    id: {},
    role: {},
    step: {},
    largeStep: {},
    autoComplete: {},
    max: {},
    maxLength: {},
    maxHeight: {},
    min: {},
    minLength: {},
    pattern: {},
    inputMode: {},
    spellCheck: { type: Boolean },
    ariaOwns: {},
    ariaExpanded: { type: Boolean },
    ariaControls: {},
    ariaActiveDescendant: {},
    ariaAutocomplete: { default: "list" },
    showCharacterCount: { type: Boolean },
    align: {},
    requiredIndicator: { type: Boolean },
    monospaced: { type: Boolean },
    variant: {},
    size: {},
    tone: {},
    autoSize: { type: Boolean },
    loading: { type: Boolean },
    readonly: { type: Boolean }
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["clear-button-click", "input", "change", "spinner-change", "focus", "blur"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const slots = useSlots();
    const emits = __emit;
    const model = useModel(__props, "modelValue");
    const {
      activeOptionId,
      listboxId,
      expanded,
      setTextFieldFocused,
      setTextFieldLabelId,
      onTextFieldFocus,
      onTextFieldChange,
      onTextFieldBlur
    } = useComboboxTextField();
    const uniqueId = useId();
    const { hasSlot } = useHasSlot();
    const textFieldId = computed(() => props.id ?? uniqueId);
    const fieldLabelId = computed(() => labelId(String(props.id || uniqueId)));
    watch(
      () => fieldLabelId.value,
      (newVal) => {
        if (setTextFieldLabelId) setTextFieldLabelId(newVal);
      }
    );
    const handleFocus = (event) => {
      emits("focus", event);
      if (onTextFieldFocus) onTextFieldFocus();
      if (setTextFieldFocused) setTextFieldFocused(true);
    };
    const handleBlur = (event) => {
      emits("blur", event);
      if (onTextFieldBlur) onTextFieldBlur();
      if (setTextFieldFocused) setTextFieldFocused(false);
    };
    const handleChange = (value, id) => {
      emits("change", value, id);
      if (onTextFieldChange) onTextFieldChange(value);
    };
    const handleInput = (e, value) => {
      model.value = value;
      emits("input", e, value);
      if (onTextFieldChange) onTextFieldChange(value);
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1), mergeProps(props, {
        id: `${textFieldId.value}`,
        modelValue: model.value,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => model.value = $event),
        "aria-haspopup": "listbox",
        "aria-autocomplete": _ctx.ariaAutocomplete,
        "aria-active-descendant": unref(activeOptionId),
        "aria-controls": unref(listboxId),
        role: "combobox",
        "aria-expanded": unref(expanded),
        onFocus: handleFocus,
        onBlur: handleBlur,
        onChange: handleChange,
        onInput: handleInput
      }), createSlots({ _: 2 }, [
        unref(hasSlot)(slots.label) || _ctx.label ? {
          name: "label",
          fn: withCtx(() => [
            unref(hasSlot)(slots.label) ? renderSlot(_ctx.$slots, "label", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ], 64))
          ]),
          key: "0"
        } : void 0,
        unref(hasSlot)(slots.helpText) || _ctx.helpText ? {
          name: "helpText",
          fn: withCtx(() => [
            unref(hasSlot)(slots.helpText) ? renderSlot(_ctx.$slots, "helpText", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.helpText), 1)
            ], 64))
          ]),
          key: "1"
        } : void 0,
        Boolean(slots.connectedLeft) ? {
          name: "connectedLeft",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "connectedLeft")
          ]),
          key: "2"
        } : void 0,
        Boolean(slots.connectedRight) ? {
          name: "connectedRight",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "connectedRight")
          ]),
          key: "3"
        } : void 0,
        unref(hasSlot)(slots.prefix) || _ctx.prefix ? {
          name: "prefix",
          fn: withCtx(() => [
            unref(hasSlot)(slots.prefix) ? renderSlot(_ctx.$slots, "prefix", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.prefix), 1)
            ], 64))
          ]),
          key: "4"
        } : void 0,
        unref(hasSlot)(slots.suffix) || _ctx.suffix ? {
          name: "suffix",
          fn: withCtx(() => [
            unref(hasSlot)(slots.suffix) ? renderSlot(_ctx.$slots, "suffix", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.suffix), 1)
            ], 64))
          ]),
          key: "5"
        } : void 0,
        unref(hasSlot)(slots.verticalContent) || _ctx.verticalContent ? {
          name: "verticalContent",
          fn: withCtx(() => [
            unref(hasSlot)(slots.verticalContent) ? renderSlot(_ctx.$slots, "verticalContent", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.verticalContent), 1)
            ], 64))
          ]),
          key: "6"
        } : void 0
      ]), 1040, ["id", "modelValue", "aria-autocomplete", "aria-active-descendant", "aria-controls", "aria-expanded"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=TextField.vue_vue_type_script_setup_true_lang.js.map
