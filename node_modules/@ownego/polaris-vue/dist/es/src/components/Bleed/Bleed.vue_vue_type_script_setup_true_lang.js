import { defineComponent, computed, openBlock, createElementBlock, normalizeStyle, unref, renderSlot } from "vue";
import { c as classNames, g as getResponsiveProps, s as sanitizeCustomProperties } from "../../utilities/css.js";
const Bleed = "Polaris-Bleed";
const styles = {
  Bleed
};
const _hoisted_1 = ["className"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Bleed",
  props: {
    marginInline: {},
    marginBlock: {},
    marginBlockStart: {},
    marginBlockEnd: {},
    marginInlineStart: {},
    marginInlineEnd: {}
  },
  setup(__props) {
    const props = __props;
    const className = computed(() => {
      return classNames(
        styles.Bleed
      );
    });
    const style = computed(() => {
      return {
        ...getResponsiveProps(
          "bleed",
          "margin-block-start",
          "space",
          negativeMarginBlockStart
        ),
        ...getResponsiveProps(
          "bleed",
          "margin-block-end",
          "space",
          negativeMarginBlockEnd
        ),
        ...getResponsiveProps(
          "bleed",
          "margin-inline-start",
          "space",
          negativeMarginInlineStart
        ),
        ...getResponsiveProps(
          "bleed",
          "margin-inline-end",
          "space",
          negativeMarginInlineEnd
        )
      };
    });
    const getNegativeMargins = (direction) => {
      const xAxis = ["marginInlineStart", "marginInlineEnd"];
      const yAxis = ["marginBlockStart", "marginBlockEnd"];
      const directionValues = {
        marginBlockStart: props.marginBlockStart,
        marginBlockEnd: props.marginBlockEnd,
        marginInlineStart: props.marginInlineStart,
        marginInlineEnd: props.marginInlineEnd,
        marginInline: props.marginInline,
        marginBlock: props.marginBlock
      };
      if (directionValues[direction]) {
        return directionValues[direction];
      } else if (xAxis.includes(direction) && props.marginInline) {
        return directionValues.marginInline;
      } else if (yAxis.includes(direction) && props.marginBlock) {
        return directionValues.marginBlock;
      }
    };
    const negativeMarginBlockStart = getNegativeMargins("marginBlockStart");
    const negativeMarginBlockEnd = getNegativeMargins("marginBlockEnd");
    const negativeMarginInlineStart = getNegativeMargins("marginInlineStart");
    const negativeMarginInlineEnd = getNegativeMargins("marginInlineEnd");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        className: className.value,
        style: normalizeStyle(unref(sanitizeCustomProperties)(style.value))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 12, _hoisted_1);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Bleed.vue_vue_type_script_setup_true_lang.js.map
