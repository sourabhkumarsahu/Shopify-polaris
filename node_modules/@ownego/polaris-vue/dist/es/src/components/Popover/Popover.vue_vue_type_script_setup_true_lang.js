import { defineComponent, useSlots, ref, watch, onMounted, onBeforeUnmount, openBlock, createBlock, resolveDynamicComponent, withCtx, renderSlot, unref, createVNode, mergeProps, createCommentVNode } from "vue";
import { b as findFirstFocusableNodeIncludingDisabled, c as focusNextFocusableNode } from "../../utilities/focus.js";
import { p as portal } from "../../../polaris/polaris-react/src/components/shared.js";
import { u as useId } from "../../use/useId.js";
import { s as setActivatorAttributes } from "./set-activator-attributes.js";
import { P as PopoverCloseSource } from "./components/PopoverOverlay/types.js";
import { _ as _sfc_main$2 } from "./components/PopoverOverlay/PopoverOverlay.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$1 } from "../Portal/Portal.vue_vue_type_script_setup_true_lang.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Popover",
  props: {
    preferredPosition: {},
    preferredAlignment: {},
    active: { type: Boolean },
    preferInputActivator: { default: true },
    activatorWrapper: { default: "div" },
    zIndexOverride: {},
    preventFocusOnClose: { type: Boolean },
    sectioned: { type: Boolean },
    fullWidth: { type: Boolean },
    fullHeight: { type: Boolean },
    fluidContent: { type: Boolean },
    fixed: { type: Boolean },
    ariaHaspopup: { type: [Boolean, String] },
    hideOnPrint: { type: Boolean },
    autofocusTarget: {},
    preventCloseOnChildOverlayClick: { type: Boolean },
    captureOverscroll: { type: Boolean }
  },
  emits: ["close"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    useSlots();
    const id = useId();
    const observer = ref(null);
    const isDisplayed = ref(false);
    const activatorNode = ref(null);
    const activatorContainer = ref(null);
    const overlayRef = ref(null);
    watch(
      () => props.active,
      () => {
        setAccessibilityAttributes();
      }
    );
    const forceUpdatePosition = () => {
      overlayRef.value.forceUpdatePosition();
    };
    const setAccessibilityAttributes = () => {
      if (activatorContainer.value == null) {
        return;
      }
      const firstFocusable = findFirstFocusableNodeIncludingDisabled(activatorContainer.value);
      const focusableActivator = firstFocusable || activatorContainer.value;
      const activatorDisabled = "disabled" in focusableActivator && Boolean(focusableActivator.disabled);
      setActivatorAttributes(focusableActivator, {
        id: String(id),
        active: props.active,
        ariaHaspopup: props.ariaHaspopup,
        activatorDisabled
      });
    };
    const handleClose = (source) => {
      emits("close", source);
      if (activatorContainer.value == null || props.preventFocusOnClose) {
        return;
      }
      if (source === PopoverCloseSource.FocusOut && activatorNode.value) {
        const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode.value) || findFirstFocusableNodeIncludingDisabled(activatorContainer.value) || activatorContainer.value;
        if (!focusNextFocusableNode(focusableActivator, isInPortal)) {
          focusableActivator.focus();
        }
      } else if (source === PopoverCloseSource.EscapeKeypress && activatorNode.value) {
        const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode.value) || findFirstFocusableNodeIncludingDisabled(activatorContainer.value) || activatorContainer.value;
        if (focusableActivator) {
          focusableActivator.focus();
        } else {
          focusNextFocusableNode(focusableActivator, isInPortal);
        }
      }
    };
    onMounted(() => {
      if (!activatorNode.value && activatorContainer.value) {
        activatorNode.value = activatorContainer.value.firstElementChild;
      } else if (activatorNode.value && activatorContainer.value && !activatorContainer.value.contains(activatorNode.value)) {
        activatorNode.value = activatorContainer.value.firstElementChild;
      }
      if (activatorNode.value && activatorContainer.value) {
        activatorNode.value = activatorContainer.value.firstElementChild;
      }
      if (!activatorNode.value) {
        return;
      }
      observer.value = new ResizeObserver(() => {
        setDisplayState();
      });
      observer.value.observe(activatorNode.value);
      setDisplayState();
      setAccessibilityAttributes();
    });
    onBeforeUnmount(() => {
      var _a;
      (_a = observer.value) == null ? void 0 : _a.disconnect();
    });
    function isInPortal(element) {
      let { parentElement } = element;
      while (parentElement) {
        if (parentElement.matches(portal.selector)) {
          return false;
        }
        parentElement = parentElement.parentElement;
      }
      return true;
    }
    function setDisplayState() {
      isDisplayed.value = Boolean(
        activatorContainer.value && (activatorContainer.value.offsetParent !== null || activatorContainer.value === activatorContainer.value.ownerDocument.body && activatorContainer.value.clientWidth > 0)
      );
    }
    __expose({
      forceUpdatePosition,
      close: (target = "activator") => {
        const source = target === "activator" ? PopoverCloseSource.EscapeKeypress : PopoverCloseSource.FocusOut;
        handleClose(source);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.activatorWrapper), {
        ref_key: "activatorContainer",
        ref: activatorContainer
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "activator"),
          activatorNode.value && isDisplayed.value ? (openBlock(), createBlock(unref(_sfc_main$1), {
            key: 0,
            "id-prefix": "popover"
          }, {
            default: withCtx(() => [
              createVNode(unref(_sfc_main$2), mergeProps({
                ref_key: "overlayRef",
                ref: overlayRef
              }, props, {
                id: String(unref(id)),
                activator: activatorNode.value,
                preferInputActivator: _ctx.preferInputActivator,
                active: _ctx.active,
                fixed: _ctx.fixed,
                "z-index-override": _ctx.zIndexOverride,
                onClose: handleClose
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["id", "activator", "preferInputActivator", "active", "fixed", "z-index-override"])
            ]),
            _: 3
          })) : createCommentVNode("", true)
        ]),
        _: 3
      }, 512);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Popover.vue_vue_type_script_setup_true_lang.js.map
