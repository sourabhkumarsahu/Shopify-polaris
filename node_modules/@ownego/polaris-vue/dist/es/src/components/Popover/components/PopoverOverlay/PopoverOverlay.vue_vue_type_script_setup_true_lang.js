import { defineComponent, useSlots, reactive, ref, computed, watch, onMounted, onBeforeUnmount, openBlock, createBlock, unref, normalizeClass, withCtx, createElementVNode, mergeProps, createVNode, normalizeStyle, renderSlot, createCommentVNode } from "vue";
import { s as styles, _ as _sfc_main$4 } from "../Pane/Pane.vue_vue_type_script_setup_true_lang.js";
import { u as themeDefault } from "../../../../../vendor.js";
import { o as overlay } from "../../../../../polaris/polaris-react/src/components/shared.js";
import { c as classNames } from "../../../../utilities/css.js";
import { u as usePortalsManager } from "../../../../use/usePortalsManager.js";
import { d as findFirstKeyboardFocusableNode } from "../../../../utilities/focus.js";
import { i as isElementOfType } from "../../../../utilities/component.js";
import { K as Key } from "../../../../utilities/types.js";
import { _ as _sfc_main$2 } from "../../../EventListener/EventListener.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$3 } from "../../../KeypressListener/KeypressListener.vue_vue_type_script_setup_true_lang.js";
import { P as PopoverCloseSource } from "./types.js";
import { _ as _sfc_main$1 } from "../../../PositionedOverlay/PositionedOverlay.vue_vue_type_script_setup_true_lang.js";
const _hoisted_1 = ["id", "tabindex"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "PopoverOverlay",
  props: {
    fullWidth: { type: Boolean },
    fullHeight: { type: Boolean },
    fluidContent: { type: Boolean },
    preferredPosition: { default: "below" },
    preferredAlignment: { default: "center" },
    active: { type: Boolean },
    id: {},
    zIndexOverride: {},
    activator: {},
    preferInputActivator: { type: Boolean, default: true },
    sectioned: { type: Boolean },
    fixed: { type: Boolean },
    hideOnPrint: { type: Boolean },
    autofocusTarget: {},
    preventCloseOnChildOverlayClick: { type: Boolean },
    captureOverscroll: { type: Boolean }
  },
  emits: ["close"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const slots = useSlots();
    const context = usePortalsManager();
    const props = __props;
    const emits = __emit;
    const state = reactive({
      transitionStatus: props.active ? "entering" : "exited"
      /* Exited */
    });
    const contentNode = ref(null);
    const enteringTimer = ref(void 0);
    const overlayRef = ref(null);
    const observer = ref(null);
    const window = ref(globalThis.window);
    const overlayDetails = computed(() => {
      var _a;
      return (_a = overlayRef.value) == null ? void 0 : _a.overlayDetails;
    });
    const positionOverlayClass = computed(() => {
      return classNames(
        styles.PopoverOverlay,
        state.transitionStatus === "entering" && styles["PopoverOverlay-entering"],
        state.transitionStatus === "entered" && styles["PopoverOverlay-open"],
        state.transitionStatus === "exiting" && styles["PopoverOverlay-exiting"]
      );
    });
    const popoverOverlayClass = computed(() => {
      var _a, _b;
      return classNames(
        styles.Popover,
        ((_a = overlayDetails.value) == null ? void 0 : _a.positioning) === "above" && styles.positionedAbove,
        props.fullWidth && styles.fullWidth,
        ((_b = overlayDetails.value) == null ? void 0 : _b.measuring) && styles.measuring,
        props.hideOnPrint && styles["PopoverOverlay-hideOnPrint"]
      );
    });
    const contentStyles = computed(() => {
      var _a, _b;
      return ((_a = overlayDetails.value) == null ? void 0 : _a.measuring) ? void 0 : { height: `${(_b = overlayDetails.value) == null ? void 0 : _b.desiredHeight}px` };
    });
    const contentClassNames = computed(() => {
      return classNames(
        styles.Content,
        props.fullHeight && styles["Content-fullHeight"],
        props.fluidContent && styles["Content-fluidContent"]
      );
    });
    const isChildContentWrappedByPane = computed(() => {
      var _a;
      const childContents = ((_a = slots.default) == null ? void 0 : _a.call(slots)) || [];
      if (!childContents.length) {
        return false;
      }
      const children = childContents[0].children && childContents[0].children.length ? childContents[0].children[0] : childContents[0];
      return isElementOfType(children, _sfc_main$4);
    });
    watch(
      () => props.active,
      (newVal, oldVal) => {
        if (newVal && !oldVal) {
          focusContent();
          changeTransitionStatus("entering", () => {
            clearTransitionTimeout();
            enteringTimer.value = window.value.setTimeout(() => {
              state.transitionStatus = "entered";
            }, parseInt(themeDefault.motion["motion-duration-100"], 10));
          });
        }
        if (!newVal && oldVal) {
          clearTransitionTimeout();
          state.transitionStatus = "exited";
        }
      }
    );
    watch(
      () => props.activator,
      (newVal, oldVal) => {
        var _a, _b;
        if (newVal !== oldVal) {
          (_a = observer.value) == null ? void 0 : _a.unobserve(oldVal);
          (_b = observer.value) == null ? void 0 : _b.observe(newVal);
        }
      }
    );
    onMounted(() => {
      if (props.active) {
        focusContent();
        changeTransitionStatus(
          "entered"
          /* Entered */
        );
      }
      if (!props.activator) return;
      observer.value = new ResizeObserver(() => {
        window.value = props.activator.ownerDocument.defaultView;
      });
      observer.value.observe(props.activator);
    });
    onBeforeUnmount(() => {
      var _a;
      clearTransitionTimeout();
      (_a = observer.value) == null ? void 0 : _a.disconnect();
    });
    const changeTransitionStatus = (transitionStatus, callback) => {
      state.transitionStatus = transitionStatus;
      callback && callback();
      contentNode.value && contentNode.value.getBoundingClientRect();
    };
    function clearTransitionTimeout() {
      if (enteringTimer.value) {
        window.value.clearTimeout(enteringTimer.value);
      }
    }
    function focusContent() {
      const { autofocusTarget = "container" } = props;
      if (autofocusTarget === "none" || contentNode.value === null) {
        return;
      }
      requestAnimationFrame(() => {
        if (contentNode.value === null) {
          return;
        }
        const focusableChild = findFirstKeyboardFocusableNode(contentNode.value);
        if (focusableChild && autofocusTarget === "first-node") {
          focusableChild.focus({
            preventScroll: process.env.NODE_ENV === "development"
          });
        } else {
          contentNode.value.focus({
            preventScroll: process.env.NODE_ENV === "development"
          });
        }
      });
    }
    function handleClick(event) {
      const target = event.target;
      const { activator, preventCloseOnChildOverlayClick } = props;
      const composedPath = event.composedPath();
      const wasDescendant = preventCloseOnChildOverlayClick ? wasPolarisPortalDescendant(composedPath, context) : wasContentNodeDescendant(composedPath, contentNode);
      const isActivatorDescendant = nodeContainsDescendant(activator, target);
      if (wasDescendant || isActivatorDescendant || state.transitionStatus !== "entered") {
        return;
      }
      emits("close", PopoverCloseSource.Click);
    }
    function handleScrollOut() {
      emits("close", PopoverCloseSource.ScrollOut);
    }
    function handleEscape(event) {
      const target = event.target;
      const { activator } = props;
      const composedPath = event.composedPath();
      const wasDescendant = wasContentNodeDescendant(composedPath, contentNode);
      const isActivatorDescendant = nodeContainsDescendant(activator, target);
      if (wasDescendant || isActivatorDescendant) {
        emits("close", PopoverCloseSource.EscapeKeypress);
      }
    }
    function handleFocusFirstItem() {
      emits("close", PopoverCloseSource.FocusOut);
    }
    function handleFocusLastItem() {
      emits("close", PopoverCloseSource.FocusOut);
    }
    function nodeContainsDescendant(rootNode, descendant) {
      if (rootNode === descendant) {
        return true;
      }
      let parent = descendant.parentNode;
      while (parent != null) {
        if (parent === rootNode) {
          return true;
        }
        parent = parent.parentNode;
      }
      return false;
    }
    function wasContentNodeDescendant(composedPath, contentNode2) {
      return contentNode2.value != null && composedPath.includes(contentNode2.value);
    }
    function wasPolarisPortalDescendant(composedPath, portalsContainerElement) {
      return composedPath.some((eventTarget) => {
        var _a;
        return eventTarget instanceof Node && ((_a = portalsContainerElement.value) == null ? void 0 : _a.contains(eventTarget));
      });
    }
    function forceUpdatePosition() {
      overlayRef.value.forceUpdatePosition();
    }
    __expose({ forceUpdatePosition });
    return (_ctx, _cache) => {
      return state.transitionStatus !== "exited" && _ctx.active ? (openBlock(), createBlock(unref(_sfc_main$1), {
        key: 0,
        ref_key: "overlayRef",
        ref: overlayRef,
        "full-width": _ctx.fullWidth,
        active: _ctx.active,
        activator: _ctx.activator,
        "prefer-input-activator": _ctx.preferInputActivator,
        "preferred-position": _ctx.preferredPosition,
        "preferred-alignment": _ctx.preferredAlignment,
        fixed: _ctx.fixed,
        class: normalizeClass(positionOverlayClass.value),
        "z-index-override": _ctx.zIndexOverride,
        onScrollOut: handleScrollOut
      }, {
        default: withCtx(() => [
          createElementVNode("div", mergeProps(unref(overlay).props, { class: popoverOverlayClass.value }), [
            createVNode(unref(_sfc_main$2), {
              event: "click",
              handler: handleClick,
              "custom-window": window.value
            }, null, 8, ["custom-window"]),
            createVNode(unref(_sfc_main$2), {
              event: "touchstart",
              handler: handleClick,
              "custom-window": window.value
            }, null, 8, ["custom-window"]),
            createVNode(unref(_sfc_main$3), {
              "key-code": unref(Key).Escape,
              handler: handleEscape,
              "custom-window": window.value
            }, null, 8, ["key-code", "custom-window"]),
            createElementVNode("div", {
              tabindex: "0",
              class: normalizeClass(unref(styles).FocusTracker),
              onFocus: handleFocusFirstItem
            }, null, 34),
            createElementVNode("div", {
              class: normalizeClass(unref(styles).ContentContainer)
            }, [
              createElementVNode("div", {
                ref_key: "contentNode",
                ref: contentNode,
                id: _ctx.id,
                tabindex: _ctx.autofocusTarget === "none" ? void 0 : -1,
                class: normalizeClass(contentClassNames.value),
                style: normalizeStyle(contentStyles.value)
              }, [
                isChildContentWrappedByPane.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createBlock(unref(_sfc_main$4), {
                  key: 1,
                  "capture-overscroll": _ctx.captureOverscroll,
                  sectioned: _ctx.sectioned
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["capture-overscroll", "sectioned"]))
              ], 14, _hoisted_1)
            ], 2),
            createElementVNode("div", {
              class: normalizeClass(unref(styles).FocusTracker),
              tabindex: "0",
              onFocus: handleFocusLastItem
            }, null, 34)
          ], 16)
        ]),
        _: 3
      }, 8, ["full-width", "active", "activator", "prefer-input-activator", "preferred-position", "preferred-alignment", "fixed", "class", "z-index-override"])) : createCommentVNode("", true);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=PopoverOverlay.vue_vue_type_script_setup_true_lang.js.map
