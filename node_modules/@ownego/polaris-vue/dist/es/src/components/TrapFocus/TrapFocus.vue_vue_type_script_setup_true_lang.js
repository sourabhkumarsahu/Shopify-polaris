import { defineComponent, ref, watch, openBlock, createBlock, unref, withCtx, createElementVNode, createVNode, renderSlot } from "vue";
import { p as portal } from "../../../polaris/polaris-react/src/components/shared.js";
import { f as focusFirstFocusableNode, d as findFirstKeyboardFocusableNode, g as findLastKeyboardFocusableNode, i as focusFirstKeyboardFocusableNode, j as focusLastKeyboardFocusableNode } from "../../utilities/focus.js";
import { K as Key } from "../../utilities/types.js";
import { a as useFocusManager } from "../../use/useFocusManager.js";
import { _ as _sfc_main$2 } from "../EventListener/EventListener.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$1 } from "../Focus/Focus.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$3 } from "../KeypressListener/KeypressListener.vue_vue_type_script_setup_true_lang.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "TrapFocus",
  props: {
    trapping: { type: Boolean, default: true }
  },
  setup(__props) {
    const props = __props;
    const { canSafelyFocus } = useFocusManager({ trapping: props.trapping });
    const wrapperNode = ref(null);
    const disableFocus = ref(true);
    watch([() => props.trapping], () => {
      disableFocus.value = canSafelyFocus.value && !(wrapperNode.value && wrapperNode.value.contains(document.activeElement)) ? !props.trapping : true;
    });
    const handleFocusIn = (event) => {
      if (!props.trapping || !wrapperNode.value || wrapperNode.value.contains(document.activeElement) || event.target instanceof Element && event.target.matches(`${portal.selector} *`)) {
        return;
      }
      if (canSafelyFocus.value && event.target instanceof HTMLElement && wrapperNode.value !== event.target && wrapperNode.value.contains(event.target)) {
        focusFirstFocusableNode(wrapperNode.value);
      }
    };
    const handleTab = (event) => {
      if (!props.trapping || !wrapperNode.value) {
        return;
      }
      const firstFocusableNode = findFirstKeyboardFocusableNode(wrapperNode.value);
      const lastFocusableNode = findLastKeyboardFocusableNode(wrapperNode.value);
      if (event.target === lastFocusableNode && !event.shiftKey) {
        event.preventDefault();
        focusFirstKeyboardFocusableNode(wrapperNode.value);
      }
      if (event.target === firstFocusableNode && event.shiftKey) {
        event.preventDefault();
        focusLastKeyboardFocusableNode(wrapperNode.value);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1), {
        disabled: disableFocus.value,
        root: wrapperNode.value
      }, {
        default: withCtx(() => [
          createElementVNode("div", {
            ref_key: "wrapperNode",
            ref: wrapperNode
          }, [
            createVNode(unref(_sfc_main$2), {
              event: "focusin",
              handler: handleFocusIn
            }),
            createVNode(unref(_sfc_main$3), {
              "key-code": unref(Key).Tab,
              handler: handleTab,
              "key-event": "keydown"
            }, null, 8, ["key-code"]),
            renderSlot(_ctx.$slots, "default")
          ], 512)
        ]),
        _: 3
      }, 8, ["disabled", "root"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=TrapFocus.vue_vue_type_script_setup_true_lang.js.map
