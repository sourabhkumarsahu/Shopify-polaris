import { defineComponent, useSlots, ref, computed, onMounted, onBeforeUnmount, provide, openBlock, createElementBlock, mergeProps, unref, renderSlot } from "vue";
import { s as scrollable } from "../../../polaris/polaris-react/src/components/shared.js";
import { d as debounce } from "../../../polaris/polaris-react/src/utilities/debounce.js";
import { c as classNames, v as variationName } from "../../utilities/css.js";
import { S as StickyManager } from "../../utilities/sticky-manager/sticky-manager.js";
const Scrollable = "Polaris-Scrollable";
const hasTopShadow = "Polaris-Scrollable--hasTopShadow";
const hasBottomShadow = "Polaris-Scrollable--hasBottomShadow";
const horizontal = "Polaris-Scrollable--horizontal";
const vertical = "Polaris-Scrollable--vertical";
const scrollbarWidthThin = "Polaris-Scrollable--scrollbarWidthThin";
const scrollbarWidthNone = "Polaris-Scrollable--scrollbarWidthNone";
const scrollbarWidthAuto = "Polaris-Scrollable--scrollbarWidthAuto";
const scrollbarGutterStable = "Polaris-Scrollable--scrollbarGutterStable";
const styles = {
  Scrollable,
  hasTopShadow,
  hasBottomShadow,
  horizontal,
  vertical,
  scrollbarWidthThin,
  scrollbarWidthNone,
  scrollbarWidthAuto,
  scrollbarGutterStable,
  "scrollbarGutterStableboth-edges": "Polaris-Scrollable__scrollbarGutterStableboth--edges"
};
const _hoisted_1 = ["tabindex"];
const MAX_SCROLL_HINT_DISTANCE = 100;
const LOW_RES_BUFFER = 2;
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Scrollable",
  props: {
    vertical: { type: Boolean, default: true },
    horizontal: { type: Boolean, default: true },
    shadow: { type: Boolean },
    hint: { type: Boolean },
    focusable: { type: Boolean },
    scrollbarWidth: { default: "thin" },
    scrollbarGutter: {}
  },
  emits: ["scrolledToBottom"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useSlots();
    const emits = __emit;
    const topShadow = ref(false);
    const bottomShadow = ref(false);
    const scrollArea = ref(null);
    const stickyManager = ref(new StickyManager());
    const finalClassName = computed(() => classNames(
      styles.Scrollable,
      props.vertical && styles.vertical,
      props.horizontal && styles.horizontal,
      props.shadow && topShadow.value && styles.hasTopShadow,
      props.shadow && bottomShadow.value && styles.hasBottomShadow,
      props.scrollbarWidth && styles[variationName("scrollbarWidth", props.scrollbarWidth)],
      props.scrollbarGutter && styles[variationName("scrollbarGutter", props.scrollbarGutter.replace(" ", ""))]
    ));
    const setTopShadow = (value) => {
      topShadow.value = value;
    };
    const setBottomShadow = (value) => {
      bottomShadow.value = value;
    };
    const scrollTo = (scrollY, options = {}) => {
      var _a;
      const optionsBehavior = options.behavior || "smooth";
      const behavior = prefersReducedMotion() ? "auto" : optionsBehavior;
      (_a = scrollArea.value) == null ? void 0 : _a.scrollTo({ top: scrollY, behavior });
    };
    const handleScroll = () => {
      const currentScrollArea = scrollArea.value;
      if (!currentScrollArea) {
        return;
      }
      requestAnimationFrame(() => {
        const {
          scrollTop,
          clientHeight,
          scrollHeight
        } = currentScrollArea;
        const canScroll = Boolean(scrollHeight > clientHeight);
        const isBelowTopOfScroll = Boolean(scrollTop > 0);
        const isAtBottomOfScroll = Boolean(scrollTop + clientHeight >= scrollHeight - LOW_RES_BUFFER);
        setTopShadow(isBelowTopOfScroll);
        setBottomShadow(!isAtBottomOfScroll);
        if (canScroll && isAtBottomOfScroll) {
          emits("scrolledToBottom");
        }
      });
    };
    const handleResize = debounce(handleScroll, 50, { trailing: true });
    onMounted(() => {
      handleScroll();
      if (props.hint) {
        requestAnimationFrame(() => performScrollHint(scrollArea.value));
      }
      const currentScrollArea = scrollArea.value;
      if (currentScrollArea) {
        stickyManager.value.setContainer(currentScrollArea);
        currentScrollArea.addEventListener("scroll", handleScroll);
        globalThis.addEventListener("resize", handleResize);
      }
    });
    onBeforeUnmount(() => {
      const currentScrollArea = scrollArea.value;
      if (currentScrollArea) {
        currentScrollArea.removeEventListener("scroll", handleScroll);
        globalThis.removeEventListener("resize", handleResize);
      }
    });
    const prefersReducedMotion = () => {
      try {
        return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      } catch (err) {
        return false;
      }
    };
    const performScrollHint = (elem) => {
      if (!elem || prefersReducedMotion()) {
        return;
      }
      const scrollableDistance = elem.scrollHeight - elem.clientHeight;
      const distanceToPeek = Math.min(MAX_SCROLL_HINT_DISTANCE, scrollableDistance) - LOW_RES_BUFFER;
      const goBackToTop = () => {
        requestAnimationFrame(() => {
          if (elem.scrollTop >= distanceToPeek) {
            elem.removeEventListener("scroll", goBackToTop);
            elem.scrollTo({ top: 0, behavior: "smooth" });
          }
        });
      };
      elem.addEventListener("scroll", goBackToTop);
      elem.scrollTo({ top: MAX_SCROLL_HINT_DISTANCE, behavior: "smooth" });
    };
    provide("scrollable", scrollTo);
    provide("sticky-manager", stickyManager);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps({
        ref_key: "scrollArea",
        ref: scrollArea,
        class: finalClassName.value,
        tabindex: _ctx.focusable ? 0 : void 0
      }, unref(scrollable).props), [
        renderSlot(_ctx.$slots, "default")
      ], 16, _hoisted_1);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Scrollable.vue_vue_type_script_setup_true_lang.js.map
