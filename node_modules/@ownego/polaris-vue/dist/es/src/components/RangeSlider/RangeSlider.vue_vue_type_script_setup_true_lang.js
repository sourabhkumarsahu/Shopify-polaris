import { defineComponent, mergeModels, useSlots, useModel, computed, h, openBlock, createBlock, resolveDynamicComponent, unref, mergeProps, createSlots, withCtx, renderSlot, createElementBlock, Fragment, createTextVNode, toDisplayString } from "vue";
import { _ as _sfc_main$2 } from "./components/SingleThumb/SingleThumb.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$1 } from "./components/DualThumb/DualThumb.vue_vue_type_script_setup_true_lang.js";
import { u as useId } from "../../use/useId.js";
import { u as useHasSlot } from "../../use/useHasSlot.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "RangeSlider",
  props: /* @__PURE__ */ mergeModels({
    modelValue: {},
    label: {},
    labelAction: {},
    labelHidden: { type: Boolean },
    id: {},
    min: { default: 0 },
    max: { default: 100 },
    step: { default: 1 },
    output: { type: Boolean },
    helpText: {},
    error: {},
    disabled: { type: Boolean },
    prefix: {},
    suffix: {}
  }, {
    "modelValue": {
      required: true
    },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["change", "focus", "blur"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const slots = useSlots();
    const emits = __emit;
    const model = useModel(__props, "modelValue");
    const id = useId();
    const { hasSlot } = useHasSlot();
    const hasLabel = computed(() => hasSlot(slots.label) || props.label);
    const hasHelpText = computed(() => hasSlot(slots.helpText) || props.helpText);
    const hasPrefix = computed(() => hasSlot(slots.prefix) || props.prefix);
    const hasSuffix = computed(() => hasSlot(slots.suffix) || props.suffix);
    const sharedProps = computed(() => {
      const { id: id2, min, max, step, ...rest } = props;
      return rest;
    });
    const elm = isDualThumb(model.value) ? h(_sfc_main$1) : h(_sfc_main$2);
    const handleChange = (value) => {
      emits("change", value, `${id}`);
    };
    function isDualThumb(value) {
      return Array.isArray(value);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(elm)), mergeProps({
        id: `${unref(id)}`,
        min: _ctx.min,
        max: _ctx.max,
        step: _ctx.step
      }, sharedProps.value, {
        modelValue: model.value,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => model.value = $event),
        onChange: handleChange
      }), createSlots({ _: 2 }, [
        hasLabel.value ? {
          name: "label",
          fn: withCtx(() => [
            slots.label ? renderSlot(_ctx.$slots, "label", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(props.label), 1)
            ], 64))
          ]),
          key: "0"
        } : void 0,
        hasHelpText.value ? {
          name: "helpText",
          fn: withCtx(() => [
            slots.helpText ? renderSlot(_ctx.$slots, "helpText", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(props.helpText), 1)
            ], 64))
          ]),
          key: "1"
        } : void 0,
        hasPrefix.value ? {
          name: "prefix",
          fn: withCtx(() => [
            slots.prefix ? renderSlot(_ctx.$slots, "prefix", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(props.prefix), 1)
            ], 64))
          ]),
          key: "2"
        } : void 0,
        hasSuffix.value ? {
          name: "suffix",
          fn: withCtx(() => [
            slots.suffix ? renderSlot(_ctx.$slots, "suffix", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(props.suffix), 1)
            ], 64))
          ]),
          key: "3"
        } : void 0
      ]), 1040, ["id", "min", "max", "step", "modelValue"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=RangeSlider.vue_vue_type_script_setup_true_lang.js.map
