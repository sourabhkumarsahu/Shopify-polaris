import { defineComponent, mergeModels, useSlots, useModel, ref, computed, onMounted, watch, onBeforeUnmount, openBlock, createBlock, unref, createSlots, withCtx, createElementVNode, normalizeClass, createElementBlock, renderSlot, Fragment, createTextVNode, toDisplayString, createCommentVNode, normalizeStyle, createVNode } from "vue";
import { d as debounce } from "../../../../../polaris/polaris-react/src/utilities/debounce.js";
import { c as classNames } from "../../../../utilities/css.js";
import { u as useHasSlot } from "../../../../use/useHasSlot.js";
import { K as Key } from "../../../../utilities/types.js";
import { u as useEventListener } from "../../../../utilities/use-event-listener.js";
import { l as labelId } from "../../../Label/utils.js";
import { _ as _sfc_main$1 } from "../../../Labelled/Labelled.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$2 } from "../../../Text/Text.vue_vue_type_script_setup_true_lang.js";
const RangeSlider = "Polaris-RangeSlider";
const sharedStyles = {
  RangeSlider,
  "Track--dashed-after": "Polaris-RangeSlider--trackDashedAfter",
  "Track--dashed": "Polaris-RangeSlider--trackDashed"
};
const DualThumb = "Polaris-RangeSlider-DualThumb";
const TrackWrapper = "Polaris-RangeSlider-DualThumb__TrackWrapper";
const disabled = "Polaris-RangeSlider-DualThumb--disabled";
const Track = "Polaris-RangeSlider-DualThumb__Track";
const error = "Polaris-RangeSlider-DualThumb--error";
const Thumbs = "Polaris-RangeSlider-DualThumb__Thumbs";
const Prefix = "Polaris-RangeSlider-DualThumb__Prefix";
const Suffix = "Polaris-RangeSlider-DualThumb__Suffix";
const Output = "Polaris-RangeSlider-DualThumb__Output";
const OutputBubble = "Polaris-RangeSlider-DualThumb__OutputBubble";
const styles = {
  DualThumb,
  TrackWrapper,
  disabled,
  Track,
  error,
  Thumbs,
  Prefix,
  Suffix,
  Output,
  OutputBubble
};
const _hoisted_1 = ["id", "aria-disabled", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-invalid", "aria-describedby", "aria-labelledby"];
const _hoisted_2 = ["for"];
const _hoisted_3 = ["id", "aria-disabled", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-invalid", "aria-describedby", "aria-labelledby"];
const _hoisted_4 = ["for"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "DualThumb",
  props: /* @__PURE__ */ mergeModels({
    modelValue: {},
    label: {},
    labelAction: {},
    labelHidden: { type: Boolean },
    id: {},
    min: {},
    max: {},
    step: {},
    output: { type: Boolean },
    helpText: {},
    error: {},
    disabled: { type: Boolean },
    prefix: {},
    suffix: {}
  }, {
    "modelValue": {
      required: true
    },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["change", "focus", "blur"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const slots = useSlots();
    const emits = __emit;
    const { hasSlot } = useHasSlot();
    const model = useModel(__props, "modelValue");
    const trackWidth = ref(0);
    const trackLeft = ref(0);
    const thumbLower = ref(null);
    const thumbUpper = ref(null);
    const track = ref(null);
    const trackWrapper = ref(null);
    const idLower = computed(() => props.id);
    const idUpper = computed(() => `${props.id}Upper`);
    const ariaDescribedBy = computed(() => {
      const describedBy = [];
      if (props.error) {
        describedBy.push(`${props.id}Error`);
      }
      return describedBy.length ? describedBy.join(" ") : void 0;
    });
    const trackWrapperClassName = computed(() => classNames(
      styles.TrackWrapper,
      props.error && styles.error,
      props.disabled && styles.disabled
    ));
    const thumbLowerClassName = computed(() => classNames(
      styles.Thumbs,
      styles.ThumbLower,
      props.disabled && styles.disabled
    ));
    const thumbUpperClassName = computed(() => classNames(
      styles.Thumbs,
      styles.ThumbUpper,
      props.disabled && styles.disabled
    ));
    const range = computed(() => props.max - props.min);
    const minValuePosition = computed(() => props.min / range.value * trackWidth.value);
    const leftPositionThumbLower = computed(
      () => model.value[0] / range.value * trackWidth.value - minValuePosition.value
    );
    const leftPositionThumbUpper = computed(
      () => model.value[1] / range.value * trackWidth.value - minValuePosition.value
    );
    const outputLowerClassName = computed(() => classNames(styles.Output, styles.OutputLower));
    const outputUpperClassName = computed(() => classNames(styles.Output, styles.OutputUpper));
    const cssVars = computed(() => ({
      "--pc-range-slider-progress-lower": `${leftPositionThumbLower.value}px`,
      "--pc-range-slider-progress-upper": `${leftPositionThumbUpper.value}px`
    }));
    const hasLabel = computed(() => hasSlot(slots.label) || props.label);
    const hasHelpText = computed(() => hasSlot(slots.helpText) || props.helpText);
    const hasPrefix = computed(() => hasSlot(slots.prefix) || props.prefix);
    const hasSuffix = computed(() => hasSlot(slots.suffix) || props.suffix);
    onMounted(() => {
      setTrackPosition();
      if (trackWrapper.value) {
        trackWrapper.value.addEventListener("touchstart", handleTouchStartTrack, { passive: false });
      }
    });
    watch(() => track.value, () => {
      setTrackPosition();
    });
    onBeforeUnmount(() => {
      if (trackWrapper.value) {
        trackWrapper.value.removeEventListener("touchstart", handleTouchStartTrack);
      }
    });
    const setTrackPosition = debounce(
      () => {
        if (track.value) {
          const thumbSize = 16;
          const { width, left } = track.value.getBoundingClientRect();
          const adjustedTrackWidth = width - thumbSize;
          const adjustedTrackLeft = left + thumbSize / 2;
          const range2 = props.max - props.min;
          const minValuePosition2 = props.min / range2 * adjustedTrackWidth;
          trackWidth.value = adjustedTrackWidth;
          trackLeft.value = adjustedTrackLeft - minValuePosition2;
        }
      },
      40,
      { leading: true, trailing: true, maxWait: 40 }
    );
    useEventListener("resize", setTrackPosition);
    const handleMouseDownThumbLower = (event) => {
      if (event.button !== 0 || props.disabled) return;
      registerMouseMoveHandler(handleMouseMoveThumbLower);
      event.stopPropagation();
    };
    const handleMouseMoveThumbLower = (event) => {
      const valueUpper = model.value[1];
      setValue(
        [actualXPosition(event.clientX), valueUpper],
        1
        /* Upper */
      );
    };
    const handleTouchStartThumbLower = (event) => {
      if (props.disabled) return;
      registerTouchMoveHandler(handleTouchMoveThumbLower);
      event.stopPropagation();
    };
    const handleTouchMoveThumbLower = (event) => {
      event.preventDefault();
      const valueUpper = model.value[1];
      setValue(
        [actualXPosition(event.touches[0].clientX), valueUpper],
        1
        /* Upper */
      );
    };
    const handleMouseDownThumbUpper = (event) => {
      if (event.button !== 0 || props.disabled) return;
      registerMouseMoveHandler(handleMouseMoveThumbUpper);
      event.stopPropagation();
    };
    const handleMouseMoveThumbUpper = (event) => {
      const valueLower = model.value[0];
      setValue(
        [valueLower, actualXPosition(event.clientX)],
        0
        /* Lower */
      );
    };
    const handleTouchStartThumbUpper = (event) => {
      if (props.disabled) return;
      registerTouchMoveHandler(handleTouchMoveThumbUpper);
      event.stopPropagation();
    };
    const handleTouchMoveThumbUpper = (event) => {
      event.preventDefault();
      const valueLower = model.value[0];
      setValue(
        [valueLower, actualXPosition(event.touches[0].clientX)],
        0
        /* Lower */
      );
    };
    const handleKeypressLower = (event) => {
      if (props.disabled) return;
      const handlerMap = {
        [Key.UpArrow]: incrementValueLower,
        [Key.RightArrow]: incrementValueLower,
        [Key.DownArrow]: decrementValueLower,
        [Key.LeftArrow]: decrementValueLower
      };
      const handler = handlerMap[event.keyCode];
      if (handler != null) {
        event.preventDefault();
        event.stopPropagation();
        handler();
      }
    };
    const handleKeypressUpper = (event) => {
      if (props.disabled) return;
      const handlerMap = {
        [Key.UpArrow]: incrementValueUpper,
        [Key.RightArrow]: incrementValueUpper,
        [Key.DownArrow]: decrementValueUpper,
        [Key.LeftArrow]: decrementValueUpper
      };
      const handler = handlerMap[event.keyCode];
      if (handler != null) {
        event.preventDefault();
        event.stopPropagation();
        handler();
      }
    };
    const incrementValueLower = () => {
      setValue(
        [model.value[0] + props.step, model.value[1]],
        1
        /* Upper */
      );
    };
    const decrementValueLower = () => {
      setValue(
        [model.value[0] - props.step, model.value[1]],
        1
        /* Upper */
      );
    };
    const incrementValueUpper = () => {
      setValue(
        [model.value[0], model.value[1] + props.step],
        0
        /* Lower */
      );
    };
    const decrementValueUpper = () => {
      setValue(
        [model.value[0], model.value[1] - props.step],
        0
        /* Lower */
      );
    };
    const setValue = (dirtyValue, control) => {
      const sanitizedValue = sanitizeValue(dirtyValue, props.min, props.max, props.step, control);
      if (isTupleEqual(sanitizedValue, model.value) === false) {
        model.value = sanitizedValue;
        emits("change", sanitizedValue, props.id);
      }
    };
    const handleMouseDownTrack = (event) => {
      if (event.button !== 0 || props.disabled) return;
      event.preventDefault();
      const clickXPosition = actualXPosition(event.clientX);
      const distanceFromLowerThumb = Math.abs(model.value[0] - clickXPosition);
      const distanceFromUpperThumb = Math.abs(model.value[1] - clickXPosition);
      if (distanceFromLowerThumb <= distanceFromUpperThumb) {
        setValue(
          [clickXPosition, model.value[1]],
          1
          /* Upper */
        );
        registerMouseMoveHandler(handleMouseMoveThumbLower);
        if (thumbLower.value) {
          thumbLower.value.focus();
        }
      } else {
        setValue(
          [model.value[0], clickXPosition],
          0
          /* Lower */
        );
        registerMouseMoveHandler(handleMouseMoveThumbUpper);
        if (thumbUpper.value) {
          thumbUpper.value.focus();
        }
      }
    };
    const handleTouchStartTrack = (event) => {
      if (props.disabled) return;
      event.preventDefault();
      const clickXPosition = actualXPosition(event.touches[0].clientX);
      const distanceFromLowerThumb = Math.abs(model.value[0] - clickXPosition);
      const distanceFromUpperThumb = Math.abs(model.value[1] - clickXPosition);
      if (distanceFromLowerThumb <= distanceFromUpperThumb) {
        setValue(
          [clickXPosition, model.value[1]],
          1
          /* Upper */
        );
        registerTouchMoveHandler(handleTouchMoveThumbLower);
        if (thumbLower.value) {
          thumbLower.value.focus();
        }
      } else {
        setValue(
          [model.value[0], clickXPosition],
          0
          /* Lower */
        );
        registerTouchMoveHandler(handleTouchMoveThumbUpper);
        if (thumbUpper.value) {
          thumbUpper.value.focus();
        }
      }
    };
    const actualXPosition = (dirtyXPosition) => {
      if (track.value) {
        const relativeX = dirtyXPosition - trackLeft.value;
        const percentageOfTrack = relativeX / trackWidth.value;
        return percentageOfTrack * (props.max - props.min);
      } else {
        return 0;
      }
    };
    function registerMouseMoveHandler(handler) {
      document.addEventListener("mousemove", handler);
      document.addEventListener(
        "mouseup",
        () => {
          document.removeEventListener("mousemove", handler);
        },
        { once: true }
      );
    }
    function registerTouchMoveHandler(handler) {
      const removeHandler = () => {
        document.removeEventListener("touchmove", handler);
        document.removeEventListener("touchend", removeHandler);
        document.removeEventListener("touchcancel", removeHandler);
      };
      document.addEventListener("touchmove", handler, { passive: false });
      document.addEventListener("touchend", removeHandler, { once: true });
      document.addEventListener("touchcancel", removeHandler, { once: true });
    }
    function sanitizeValue(value, min, max, step, control = 1) {
      let upperValue = inBoundsUpper(roundedToStep(value[1]));
      let lowerValue = inBoundsLower(roundedToStep(value[0]));
      const maxLowerValue = upperValue - step;
      const minUpperValue = lowerValue + step;
      if (control === 1 && lowerValue > maxLowerValue) {
        lowerValue = maxLowerValue;
      } else if (control === 0 && upperValue < minUpperValue) {
        upperValue = minUpperValue;
      }
      return [lowerValue, upperValue];
      function inBoundsUpper(value2) {
        const lowerMin = min + step;
        if (value2 < lowerMin) {
          return lowerMin;
        } else if (value2 > max) {
          return max;
        } else {
          return value2;
        }
      }
      function inBoundsLower(value2) {
        const upperMax = max - step;
        if (value2 < min) {
          return min;
        } else if (value2 > upperMax) {
          return upperMax;
        } else {
          return value2;
        }
      }
      function roundedToStep(value2) {
        return Math.round(value2 / step) * step;
      }
    }
    function isTupleEqual(a, b) {
      if (!a || !b) {
        return false;
      }
      return a[0] === b[0] && a[1] === b[1];
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1), {
        id: _ctx.id,
        error: _ctx.error,
        action: _ctx.labelAction,
        "label-hidden": _ctx.labelHidden
      }, createSlots({
        default: withCtx(() => [
          createElementVNode("div", {
            class: normalizeClass(unref(classNames)(unref(styles).DualThumb, unref(sharedStyles).RangeSlider))
          }, [
            hasPrefix.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(styles).Prefix)
            }, [
              slots.prefix ? renderSlot(_ctx.$slots, "prefix", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(_ctx.prefix), 1)
              ], 64))
            ], 2)) : createCommentVNode("", true),
            createElementVNode("div", {
              ref_key: "trackWrapper",
              ref: trackWrapper,
              class: normalizeClass(trackWrapperClassName.value),
              onMousedown: handleMouseDownTrack
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(styles).Track),
                style: normalizeStyle(cssVars.value),
                ref_key: "track",
                ref: track
              }, null, 6),
              createElementVNode("div", {
                class: normalizeClass(unref(sharedStyles)["Track--dashed"])
              }, null, 2),
              createElementVNode("div", {
                ref_key: "thumbLower",
                ref: thumbLower,
                id: idLower.value,
                class: normalizeClass(thumbLowerClassName.value),
                style: normalizeStyle({ left: `${leftPositionThumbLower.value}px` }),
                role: "slider",
                "aria-disabled": _ctx.disabled,
                "aria-valuemin": _ctx.min,
                "aria-valuemax": _ctx.max,
                "aria-valuenow": model.value[0],
                "aria-invalid": Boolean(_ctx.error),
                "aria-describedby": ariaDescribedBy.value,
                "aria-labelledby": unref(labelId)(_ctx.id),
                tabindex: "0",
                onFocus: _cache[0] || (_cache[0] = ($event) => emits("focus")),
                onBlur: _cache[1] || (_cache[1] = ($event) => emits("blur")),
                onKeydown: handleKeypressLower,
                onMousedown: handleMouseDownThumbLower,
                onTouchstart: handleTouchStartThumbLower
              }, null, 46, _hoisted_1),
              !_ctx.disabled && _ctx.output ? (openBlock(), createElementBlock("output", {
                key: 0,
                for: idLower.value,
                class: normalizeClass(outputLowerClassName.value),
                style: normalizeStyle({ left: `${leftPositionThumbLower.value}px` })
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(styles).OutputBubble)
                }, [
                  createVNode(unref(_sfc_main$2), {
                    as: "span",
                    variant: "headingSm",
                    alignment: "center"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(model.value[0]), 1)
                    ]),
                    _: 1
                  })
                ], 2)
              ], 14, _hoisted_2)) : createCommentVNode("", true),
              createElementVNode("div", {
                ref_key: "thumbUpper",
                ref: thumbUpper,
                id: idUpper.value,
                class: normalizeClass(thumbUpperClassName.value),
                style: normalizeStyle({ left: `${leftPositionThumbUpper.value}px` }),
                role: "slider",
                "aria-disabled": _ctx.disabled,
                "aria-valuemin": _ctx.min,
                "aria-valuemax": _ctx.max,
                "aria-valuenow": model.value[1],
                "aria-invalid": Boolean(_ctx.error),
                "aria-describedby": ariaDescribedBy.value,
                "aria-labelledby": unref(labelId)(_ctx.id),
                tabindex: "0",
                onFocus: _cache[2] || (_cache[2] = ($event) => emits("focus")),
                onBlur: _cache[3] || (_cache[3] = ($event) => emits("blur")),
                onKeydown: handleKeypressUpper,
                onMousedown: handleMouseDownThumbUpper,
                onTouchstart: handleTouchStartThumbUpper
              }, null, 46, _hoisted_3),
              !_ctx.disabled && _ctx.output ? (openBlock(), createElementBlock("output", {
                key: 1,
                for: idUpper.value,
                class: normalizeClass(outputUpperClassName.value),
                style: normalizeStyle({ left: `${leftPositionThumbUpper.value}px` })
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(styles).OutputBubble)
                }, [
                  createVNode(unref(_sfc_main$2), {
                    as: "span",
                    variant: "headingSm",
                    alignment: "center"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(model.value[1]), 1)
                    ]),
                    _: 1
                  })
                ], 2)
              ], 14, _hoisted_4)) : createCommentVNode("", true)
            ], 34),
            hasSuffix.value ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(styles).Suffix)
            }, [
              slots.suffix ? renderSlot(_ctx.$slots, "suffix", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(_ctx.suffix), 1)
              ], 64))
            ], 2)) : createCommentVNode("", true)
          ], 2)
        ]),
        _: 2
      }, [
        hasLabel.value ? {
          name: "label",
          fn: withCtx(() => [
            slots.label ? renderSlot(_ctx.$slots, "label", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ], 64))
          ]),
          key: "0"
        } : void 0,
        hasHelpText.value ? {
          name: "helpText",
          fn: withCtx(() => [
            slots.helpText ? renderSlot(_ctx.$slots, "helpText", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.helpText), 1)
            ], 64))
          ]),
          key: "1"
        } : void 0
      ]), 1032, ["id", "error", "action", "label-hidden"]);
    };
  }
});
export {
  _sfc_main as _,
  sharedStyles as s
};
//# sourceMappingURL=DualThumb.vue_vue_type_script_setup_true_lang.js.map
