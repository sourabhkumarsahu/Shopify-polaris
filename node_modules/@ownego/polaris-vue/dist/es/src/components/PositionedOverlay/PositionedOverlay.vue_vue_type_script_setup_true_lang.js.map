{"version":3,"file":"PositionedOverlay.vue_vue_type_script_setup_true_lang.js","sources":["../../../../../src/components/PositionedOverlay/PositionedOverlay.vue"],"sourcesContent":["<template lang=\"pug\">\ndiv(\n  ref=\"overlay\",\n  :class=\"className\",\n  :style=\"style\",\n)\n  EventListener(\n    event=\"resize\",\n    :handler=\"handleMeasurement\",\n    :custom-window=\"overlay?.ownerDocument.defaultView\",\n  )\n  slot\n</template>\n\n<script setup lang=\"ts\">\nimport {\n  type StyleValue,\n  nextTick,\n  ref,\n  reactive,\n  computed,\n  onMounted,\n  onUpdated,\n  onBeforeUnmount,\n} from 'vue';\nimport styles from '@polaris/components/PositionedOverlay/PositionedOverlay.module.css';\nimport { classNames } from '@/utilities/css';\nimport { getRectForNode, Rect } from '@/utilities/geometry';\nimport { forNode } from '@/utilities/scrollable/for-node';\nimport { EventListener } from '@/components';\nimport { dataPolarisTopBar } from '@polaris/components/shared';\n\nimport {\n  getMarginsForNode,\n  getZIndexForLayerFromNode,\n  isDocument,\n} from './utilities/node';\nimport {\n  calculateVerticalPosition,\n  calculateHorizontalPosition,\n  rectIsOutsideOfRect,\n  intersectionWithViewport,\n  windowRect,\n} from './utilities/math';\nimport type { PositionedOverlayProps } from './types';\nimport type { VueNode } from '@/utilities/types';\n\ntype Positioning = 'above' | 'below' | 'cover';\n\nexport interface OverlayDetails {\n  left?: number;\n  right?: number;\n  desiredHeight: number;\n  positioning: Positioning;\n  measuring: boolean;\n  activatorRect: Rect;\n  chevronOffset: number;\n}\n\ninterface State {\n  measuring: boolean;\n  activatorRect: Rect;\n  left?: number;\n  right?: number;\n  top: number;\n  height: number;\n  width: number | null;\n  positioning: Positioning;\n  zIndex: number | null;\n  outsideScrollableContainer: boolean;\n  lockPosition: boolean;\n  chevronOffset: number;\n}\n\ntype PositionedOverlayEmits = {\n  'scroll-out': [];\n}\ntype PositionedOverlaySlots = {\n  default: (_?: VueNode) => any;\n}\n\nconst OBSERVER_CONFIG = {\n  childList: true,\n  subtree: true,\n  characterData: true,\n  attributeFilter: ['style'],\n};\n\nconst props = defineProps<PositionedOverlayProps>();\n\nconst emits = defineEmits<PositionedOverlayEmits>();\n\nconst slots = defineSlots<PositionedOverlaySlots>();\n\nconst state = reactive<State>({\n  measuring: true,\n  activatorRect: getRectForNode(props.activator),\n  right: undefined,\n  left: undefined,\n  top: 0,\n  height: 0,\n  width: null,\n  positioning: 'below',\n  zIndex: null,\n  outsideScrollableContainer: false,\n  lockPosition: false,\n  chevronOffset: 0,\n});\n\nconst overlay = ref<HTMLElement | null>(null);\nconst scrollableContainers = ref<Array<HTMLElement | Document>>([]);\nconst observer = ref<MutationObserver>(new MutationObserver(handleMeasurement));\n\nconst style = computed(() => {\n  return {\n    top: state.top == null || isNaN(state.top) ? undefined : `${state.top}px`,\n    left: state.left == null || isNaN(state.left) ? undefined : `${state.left}px`,\n    right: state.right == null || isNaN(state.right) ? undefined : `${state.right}px`,\n    width: state.width == null || isNaN(state.width) ? undefined : `${state.width}px`,\n    zIndex: props.zIndexOverride || state.zIndex || undefined,\n  } as StyleValue;\n});\n\nconst className = computed(() => {\n  return classNames(\n    styles.PositionedOverlay,\n    props.fixed && styles.fixed,\n    props.preventInteraction && styles.preventInteraction,\n    props.classNames,\n  );\n});\n\nconst firstScrollableContainer = computed<HTMLElement | Document | null>(() => {\n  return scrollableContainers.value[0] ?? null;\n});\n\nconst overlayDetails = computed<OverlayDetails>(() => {\n  return {\n    measuring: state.measuring,\n    left: state.left,\n    right: state.right,\n    desiredHeight: state.height,\n    positioning: state.positioning,\n    activatorRect: state.activatorRect,\n    chevronOffset: state.chevronOffset,\n  }\n});\n\nonMounted(() => {\n  setScrollableContainers();\n\n  if (scrollableContainers.value.length && !props.fixed) {\n    registerScrollHandlers();\n  }\n\n  handleMeasurement();\n});\n\nonUpdated(() => {\n  if (\n    props.active\n    && state.top !== 0\n    && state.outsideScrollableContainer\n  ) {\n    emits('scroll-out');\n  }\n});\n\nonBeforeUnmount(() => {\n  observer.value.disconnect();\n\n  if (scrollableContainers.value.length && !props.fixed) {\n    unregisterScrollHandlers();\n  }\n});\n\nconst setScrollableContainers = () => {\n  const containers: Array<HTMLElement | Document> = [];\n  let tmpScrollableContainers = forNode(props.activator);\n\n  if (tmpScrollableContainers) {\n    containers.push(tmpScrollableContainers);\n\n    while (tmpScrollableContainers?.parentElement) {\n      tmpScrollableContainers = forNode(tmpScrollableContainers.parentElement);\n\n      containers.push(tmpScrollableContainers);\n    }\n  }\n\n  scrollableContainers.value = containers;\n};\n\nconst registerScrollHandlers = () => {\n  scrollableContainers.value.forEach((node) => {\n    node.addEventListener('scroll', handleMeasurement);\n  });\n};\n\nconst unregisterScrollHandlers = () => {\n  scrollableContainers.value.forEach((node) => {\n    node.removeEventListener('scroll', handleMeasurement);\n  });\n};\n\nconst forceUpdatePosition = () => {\n  // Wait a single animation frame before re-measuring.\n  // Consumer's may also need to setup their own timers for\n  // triggering forceUpdatePosition() `children` use animation.\n  // Ideally, forceUpdatePosition() is fired at the end of a transition event.\n  nextTick(handleMeasurement);\n}\n\nfunction handleMeasurement() {\n  const { lockPosition, top } = state;\n\n  observer.value.disconnect();\n\n  // Set state\n  state.height = 0;\n  state.positioning = 'below';\n  state.measuring = true;\n\n  nextTick(() => {\n    if (overlay.value === null || firstScrollableContainer.value === null) {\n      return;\n    }\n\n    const {\n      activator,\n      preferredPosition = 'below',\n      preferredAlignment = 'center',\n      fullWidth,\n      fixed,\n      preferInputActivator = true,\n    } = props;\n\n    const document = activator.ownerDocument;\n\n    const preferredActivator = preferInputActivator\n      ? activator.querySelector('input') || activator\n      : activator;\n\n    const activatorRect = getRectForNode(preferredActivator);\n\n    const currentOverlayRect = getRectForNode(overlay.value);\n\n    const scrollableElement = isDocument(firstScrollableContainer.value)\n      ? document.body\n      : firstScrollableContainer.value;\n    const scrollableContainerRect = getRectForNode(scrollableElement);\n\n    const overlayRect = fullWidth || preferredPosition === 'cover'\n      ? new Rect({ ...currentOverlayRect, width: activatorRect.width })\n      : currentOverlayRect;\n\n    // If `body` is 100% height, it still acts as though it were not constrained to that size. This adjusts for that.\n    if (scrollableElement === document.body) {\n      scrollableContainerRect.height = document.body.scrollHeight;\n    }\n\n    let topBarOffset = 0;\n\n    const topBarElement = scrollableElement.querySelector(`${dataPolarisTopBar.selector}`);\n\n    if (topBarElement) {\n      topBarOffset = topBarElement.clientHeight;\n    }\n\n    /**\n     * Original version of below code was overlay.value.firstElementChild && overlay.value.firstChild instanceof HTMLElement\n     * overlay.value.firstChild will be true if there is a text node inside overlay.value\n     * -> this case seem like will never happen\n     * -> remove overlay.value.firstChild instanceof HTMLElement and use overlay.value.firstElementChild only\n     *\n     * Note:\n     * - With original version if overlay.value.firstElementChild is available and overlay.value.firstChild is not then there will be small padding below popover\n     */\n    let overlayMargins = {activator: 0, container: 0, horizontal: 0};\n\n    if (overlay.value.firstElementChild) {\n      const nodeMargins = getMarginsForNode(\n        overlay.value.firstElementChild as HTMLElement,\n      );\n\n      overlayMargins = nodeMargins;\n    }\n\n    const containerRect = windowRect(props.activator);\n    const zIndexForLayer = getZIndexForLayerFromNode(activator);\n    const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;\n    const verticalPosition = calculateVerticalPosition(\n      activatorRect,\n      overlayRect,\n      overlayMargins,\n      scrollableContainerRect,\n      containerRect,\n      preferredPosition,\n      fixed,\n      topBarOffset,\n    );\n\n    const horizontalPosition = calculateHorizontalPosition(\n      activatorRect,\n      overlayRect,\n      containerRect,\n      overlayMargins,\n      preferredAlignment,\n    );\n\n    const tmpChevronOffset = activatorRect.center.x - horizontalPosition + overlayMargins.horizontal * 2;\n\n    state.measuring = false;\n    state.activatorRect = getRectForNode(activator);\n    state.left = preferredAlignment !== 'right' ? horizontalPosition : undefined;\n    state.right = preferredAlignment === 'right' ? horizontalPosition : undefined;\n    state.top = lockPosition ? top : verticalPosition.top;\n    state.lockPosition = Boolean(fixed);\n    state.height = verticalPosition.height || 0;\n    state.width = fullWidth || preferredPosition === 'cover' ? overlayRect.width : null;\n    state.positioning = verticalPosition.positioning as Positioning;\n    state.outsideScrollableContainer = rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect, containerRect));\n    state.zIndex = zIndex;\n    state.chevronOffset = tmpChevronOffset;\n\n    nextTick(() => {\n      if (!overlay.value) {\n        return;\n      }\n\n      observer.value.observe(overlay.value, OBSERVER_CONFIG);\n      observer.value.observe(activator, OBSERVER_CONFIG);\n    });\n  });\n}\n\ndefineExpose({\n  forceUpdatePosition,\n  overlayDetails,\n});\n</script>\n"],"names":["_useSlots","fixed"],"mappings":"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"}