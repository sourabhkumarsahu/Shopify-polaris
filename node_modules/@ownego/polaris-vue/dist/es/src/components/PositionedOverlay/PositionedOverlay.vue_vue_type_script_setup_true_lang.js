import { defineComponent, useSlots, reactive, ref, computed, onMounted, onUpdated, onBeforeUnmount, nextTick, openBlock, createElementBlock, normalizeClass, normalizeStyle, createVNode, unref, renderSlot } from "vue";
import { c as classNames } from "../../utilities/css.js";
import { g as getRectForNode, R as Rect } from "../../utilities/geometry.js";
import { f as forNode } from "../../utilities/scrollable/for-node.js";
import { d as dataPolarisTopBar } from "../../../polaris/polaris-react/src/components/shared.js";
import { _ as _sfc_main$1 } from "../EventListener/EventListener.vue_vue_type_script_setup_true_lang.js";
import { i as isDocument, g as getMarginsForNode, a as getZIndexForLayerFromNode } from "./utilities/node.js";
import { w as windowRect, c as calculateVerticalPosition, a as calculateHorizontalPosition, r as rectIsOutsideOfRect, i as intersectionWithViewport } from "./utilities/math.js";
const PositionedOverlay = "Polaris-PositionedOverlay";
const fixed = "Polaris-PositionedOverlay--fixed";
const calculating = "Polaris-PositionedOverlay--calculating";
const preventInteraction = "Polaris-PositionedOverlay--preventInteraction";
const styles = {
  PositionedOverlay,
  fixed,
  calculating,
  preventInteraction
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "PositionedOverlay",
  props: {
    active: { type: Boolean },
    activator: {},
    preferInputActivator: { type: Boolean },
    preferredPosition: {},
    preferredAlignment: {},
    fullWidth: { type: Boolean },
    fixed: { type: Boolean },
    preventInteraction: { type: Boolean },
    classNames: {},
    zIndexOverride: {}
  },
  emits: ["scroll-out"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const OBSERVER_CONFIG = {
      childList: true,
      subtree: true,
      characterData: true,
      attributeFilter: ["style"]
    };
    const props = __props;
    const emits = __emit;
    useSlots();
    const state = reactive({
      measuring: true,
      activatorRect: getRectForNode(props.activator),
      right: void 0,
      left: void 0,
      top: 0,
      height: 0,
      width: null,
      positioning: "below",
      zIndex: null,
      outsideScrollableContainer: false,
      lockPosition: false,
      chevronOffset: 0
    });
    const overlay = ref(null);
    const scrollableContainers = ref([]);
    const observer = ref(new MutationObserver(handleMeasurement));
    const style = computed(() => {
      return {
        top: state.top == null || isNaN(state.top) ? void 0 : `${state.top}px`,
        left: state.left == null || isNaN(state.left) ? void 0 : `${state.left}px`,
        right: state.right == null || isNaN(state.right) ? void 0 : `${state.right}px`,
        width: state.width == null || isNaN(state.width) ? void 0 : `${state.width}px`,
        zIndex: props.zIndexOverride || state.zIndex || void 0
      };
    });
    const className = computed(() => {
      return classNames(
        styles.PositionedOverlay,
        props.fixed && styles.fixed,
        props.preventInteraction && styles.preventInteraction,
        props.classNames
      );
    });
    const firstScrollableContainer = computed(() => {
      return scrollableContainers.value[0] ?? null;
    });
    const overlayDetails = computed(() => {
      return {
        measuring: state.measuring,
        left: state.left,
        right: state.right,
        desiredHeight: state.height,
        positioning: state.positioning,
        activatorRect: state.activatorRect,
        chevronOffset: state.chevronOffset
      };
    });
    onMounted(() => {
      setScrollableContainers();
      if (scrollableContainers.value.length && !props.fixed) {
        registerScrollHandlers();
      }
      handleMeasurement();
    });
    onUpdated(() => {
      if (props.active && state.top !== 0 && state.outsideScrollableContainer) {
        emits("scroll-out");
      }
    });
    onBeforeUnmount(() => {
      observer.value.disconnect();
      if (scrollableContainers.value.length && !props.fixed) {
        unregisterScrollHandlers();
      }
    });
    const setScrollableContainers = () => {
      const containers = [];
      let tmpScrollableContainers = forNode(props.activator);
      if (tmpScrollableContainers) {
        containers.push(tmpScrollableContainers);
        while (tmpScrollableContainers == null ? void 0 : tmpScrollableContainers.parentElement) {
          tmpScrollableContainers = forNode(tmpScrollableContainers.parentElement);
          containers.push(tmpScrollableContainers);
        }
      }
      scrollableContainers.value = containers;
    };
    const registerScrollHandlers = () => {
      scrollableContainers.value.forEach((node) => {
        node.addEventListener("scroll", handleMeasurement);
      });
    };
    const unregisterScrollHandlers = () => {
      scrollableContainers.value.forEach((node) => {
        node.removeEventListener("scroll", handleMeasurement);
      });
    };
    const forceUpdatePosition = () => {
      nextTick(handleMeasurement);
    };
    function handleMeasurement() {
      const { lockPosition, top } = state;
      observer.value.disconnect();
      state.height = 0;
      state.positioning = "below";
      state.measuring = true;
      nextTick(() => {
        if (overlay.value === null || firstScrollableContainer.value === null) {
          return;
        }
        const {
          activator,
          preferredPosition = "below",
          preferredAlignment = "center",
          fullWidth,
          fixed: fixed2,
          preferInputActivator = true
        } = props;
        const document = activator.ownerDocument;
        const preferredActivator = preferInputActivator ? activator.querySelector("input") || activator : activator;
        const activatorRect = getRectForNode(preferredActivator);
        const currentOverlayRect = getRectForNode(overlay.value);
        const scrollableElement = isDocument(firstScrollableContainer.value) ? document.body : firstScrollableContainer.value;
        const scrollableContainerRect = getRectForNode(scrollableElement);
        const overlayRect = fullWidth || preferredPosition === "cover" ? new Rect({ ...currentOverlayRect, width: activatorRect.width }) : currentOverlayRect;
        if (scrollableElement === document.body) {
          scrollableContainerRect.height = document.body.scrollHeight;
        }
        let topBarOffset = 0;
        const topBarElement = scrollableElement.querySelector(`${dataPolarisTopBar.selector}`);
        if (topBarElement) {
          topBarOffset = topBarElement.clientHeight;
        }
        let overlayMargins = { activator: 0, container: 0, horizontal: 0 };
        if (overlay.value.firstElementChild) {
          const nodeMargins = getMarginsForNode(
            overlay.value.firstElementChild
          );
          overlayMargins = nodeMargins;
        }
        const containerRect = windowRect(props.activator);
        const zIndexForLayer = getZIndexForLayerFromNode(activator);
        const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;
        const verticalPosition = calculateVerticalPosition(
          activatorRect,
          overlayRect,
          overlayMargins,
          scrollableContainerRect,
          containerRect,
          preferredPosition,
          fixed2,
          topBarOffset
        );
        const horizontalPosition = calculateHorizontalPosition(
          activatorRect,
          overlayRect,
          containerRect,
          overlayMargins,
          preferredAlignment
        );
        const tmpChevronOffset = activatorRect.center.x - horizontalPosition + overlayMargins.horizontal * 2;
        state.measuring = false;
        state.activatorRect = getRectForNode(activator);
        state.left = preferredAlignment !== "right" ? horizontalPosition : void 0;
        state.right = preferredAlignment === "right" ? horizontalPosition : void 0;
        state.top = lockPosition ? top : verticalPosition.top;
        state.lockPosition = Boolean(fixed2);
        state.height = verticalPosition.height || 0;
        state.width = fullWidth || preferredPosition === "cover" ? overlayRect.width : null;
        state.positioning = verticalPosition.positioning;
        state.outsideScrollableContainer = rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect, containerRect));
        state.zIndex = zIndex;
        state.chevronOffset = tmpChevronOffset;
        nextTick(() => {
          if (!overlay.value) {
            return;
          }
          observer.value.observe(overlay.value, OBSERVER_CONFIG);
          observer.value.observe(activator, OBSERVER_CONFIG);
        });
      });
    }
    __expose({
      forceUpdatePosition,
      overlayDetails
    });
    return (_ctx, _cache) => {
      var _a;
      return openBlock(), createElementBlock("div", {
        ref_key: "overlay",
        ref: overlay,
        class: normalizeClass(className.value),
        style: normalizeStyle(style.value)
      }, [
        createVNode(unref(_sfc_main$1), {
          event: "resize",
          handler: handleMeasurement,
          "custom-window": (_a = overlay.value) == null ? void 0 : _a.ownerDocument.defaultView
        }, null, 8, ["custom-window"]),
        renderSlot(_ctx.$slots, "default")
      ], 6);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=PositionedOverlay.vue_vue_type_script_setup_true_lang.js.map
