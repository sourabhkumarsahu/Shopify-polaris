import { defineComponent, useSlots, ref, computed, onMounted, watch, openBlock, createElementBlock, normalizeStyle, normalizeClass, renderSlot, createCommentVNode } from "vue";
import { c as classNames } from "../../utilities/css.js";
import { j as createVar } from "../../../vendor.js";
const Collapsible = "Polaris-Collapsible";
const isFullyClosed = "Polaris-Collapsible--isFullyClosed";
const expandOnPrint = "Polaris-Collapsible--expandOnPrint";
const inline = "Polaris-Collapsible--inline";
const animateIn = "Polaris-Collapsible--animateIn";
const styles = {
  Collapsible,
  isFullyClosed,
  expandOnPrint,
  inline,
  animateIn
};
const _hoisted_1 = ["id", "aria-hidden"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Collapsible",
  props: {
    id: {},
    expandOnPrint: { type: Boolean },
    open: { type: Boolean },
    variant: { default: "block" },
    transition: { type: [Boolean, Object], default: true }
  },
  emits: ["animation-end"],
  setup(__props, { emit: __emit }) {
    useSlots();
    const props = __props;
    const emits = __emit;
    const size = ref(0);
    const isOpen = ref(props.open);
    const animationState = ref("idle");
    const collapsibleContainer = ref(null);
    const vertical = computed(() => props.variant === "block");
    const isFullyOpen = computed(
      () => animationState.value === "idle" && props.open && isOpen.value
    );
    const isFullyClosed2 = computed(
      () => animationState.value === "idle" && !props.open && !isOpen.value
    );
    const animateIn2 = computed(() => typeof props.transition === "object" && props.transition.animateIn);
    const wrapperClassName = computed(() => {
      return classNames(
        styles.Collapsible,
        isFullyClosed2.value && styles.isFullyClosed,
        props.expandOnPrint && styles.expandOnPrint,
        props.variant === "inline" && styles.inline,
        animateIn2.value && styles.animateIn
      );
    });
    const zeroDurationRegex = /^0(ms|s)$/;
    const isTransitionDisabled = (transitionProp) => {
      if (typeof transitionProp === "boolean") {
        return !transitionProp;
      }
      const { duration } = transitionProp;
      if (duration && zeroDurationRegex.test(duration.trim())) {
        return true;
      }
      return false;
    };
    const transitionDisabled = computed(() => isTransitionDisabled(props.transition));
    const transitionStyles = computed(() => typeof props.transition === "object" && {
      transitionDelay: createVar(`motion-duration-${props.transition.delay ?? "0"}`),
      transitionDuration: props.transition.duration,
      transitionTimingFunction: props.transition.timingFunction
    });
    const collapsibleStyles = computed(() => {
      return {
        ...transitionStyles.value,
        ...vertical.value ? {
          maxHeight: isFullyOpen.value ? "none" : `${size.value}px`,
          overflow: isFullyOpen.value ? "visible" : "hidden"
        } : {
          maxWidth: isFullyOpen.value ? "none" : `${size.value}px`,
          overflow: isFullyOpen.value ? "visible" : "hidden"
        }
      };
    });
    const handleCompleteAnimation = (event) => {
      const target = event == null ? void 0 : event.target;
      if (target === collapsibleContainer.value) {
        animationState.value = "idle";
        isOpen.value = props.open;
        emits("animation-end");
      }
    };
    const startAnimation = () => {
      if (transitionDisabled.value) {
        isOpen.value = props.open;
        animationState.value = "idle";
        if (props.open && collapsibleContainer.value) {
          size.value = vertical.value ? collapsibleContainer.value.scrollHeight : collapsibleContainer.value.scrollWidth;
        } else {
          size.value = 0;
        }
      } else {
        animationState.value = "measuring";
      }
    };
    onMounted(() => {
      if (!props.open || !collapsibleContainer.value) return;
      size.value = vertical.value ? collapsibleContainer.value.scrollHeight : collapsibleContainer.value.scrollWidth;
    });
    watch(
      () => props.open,
      (newVal, oldVal) => {
        startAnimation();
      },
      { immediate: true }
    );
    watch(
      () => [animationState.value, props.open],
      () => {
        if (!collapsibleContainer.value) return;
        switch (animationState.value) {
          case "idle":
            break;
          case "measuring":
            size.value = vertical.value ? collapsibleContainer.value.scrollHeight : collapsibleContainer.value.scrollWidth;
            setTimeout(() => {
              animationState.value = "animating";
            }, 0);
            break;
          case "animating":
            size.value = props.open ? vertical.value ? collapsibleContainer.value.scrollHeight : collapsibleContainer.value.scrollWidth : 0;
            break;
        }
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "collapsibleContainer",
        ref: collapsibleContainer,
        id: _ctx.id,
        style: normalizeStyle(collapsibleStyles.value),
        class: normalizeClass(wrapperClassName.value),
        "aria-hidden": !_ctx.open,
        onTransitionend: handleCompleteAnimation
      }, [
        _ctx.expandOnPrint || !isFullyClosed2.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
      ], 46, _hoisted_1);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Collapsible.vue_vue_type_script_setup_true_lang.js.map
