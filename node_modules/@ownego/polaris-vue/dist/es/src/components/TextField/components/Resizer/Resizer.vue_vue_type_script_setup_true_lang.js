import { defineComponent, ref, computed, onMounted, openBlock, createElementBlock, normalizeClass, unref, createElementVNode, createCommentVNode } from "vue";
import { u as useEventListener } from "../../../../utilities/use-event-listener.js";
import { s as styles } from "../../TextField.vue_vue_type_script_setup_true_lang.js";
const _hoisted_1 = ["innerHTML"];
const _hoisted_2 = ["innerHTML"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Resizer",
  props: {
    contents: {},
    currentHeight: {},
    minimumLines: {},
    onHeightChange: { type: Function }
  },
  emits: ["height-change"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const contentNode = ref(null);
    const minimumLinesNode = ref(null);
    const animationFrame = ref();
    const currentHeight = ref(props.currentHeight ?? null);
    if (props.currentHeight !== currentHeight.value) {
      currentHeight.value = props.currentHeight || null;
    }
    const finalContents = computed(() => {
      return props.contents ? `${props.contents.replace(REPLACE_REGEX, replaceEntity)}<br>` : "<br>";
    });
    const contentsForMinimumLines = computed(() => {
      if (!props.minimumLines) return "";
      let content = "";
      for (let line = 0; line < props.minimumLines; line++) {
        content += "<br>";
      }
      return content;
    });
    onMounted(() => {
      useEventListener("resize", handleHeightCheck);
      if (animationFrame.value) {
        cancelAnimationFrame(animationFrame.value);
      }
    });
    const handleHeightCheck = () => {
      if (animationFrame.value) {
        cancelAnimationFrame(animationFrame.value);
      }
      animationFrame.value = requestAnimationFrame(() => {
        if (!contentNode.value || !minimumLinesNode.value) {
          return;
        }
        const newHeight = Math.max(
          contentNode.value.offsetHeight,
          minimumLinesNode.value.offsetHeight
        );
        if (newHeight !== currentHeight.value) {
          emits("height-change", newHeight);
        }
      });
    };
    const ENTITIES_TO_REPLACE = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "\n": "<br>",
      "\r": ""
    };
    const REPLACE_REGEX = new RegExp(
      `[${Object.keys(ENTITIES_TO_REPLACE).join()}]`,
      "g"
    );
    function replaceEntity(entity) {
      return ENTITIES_TO_REPLACE[entity];
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "aria-hidden": "",
        class: normalizeClass(unref(styles).Resizer)
      }, [
        createElementVNode("div", {
          ref_key: "contentNode",
          ref: contentNode,
          class: normalizeClass(unref(styles).DummyInput),
          innerHTML: finalContents.value
        }, null, 10, _hoisted_1),
        _ctx.minimumLines ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref_key: "minimumLinesNode",
          ref: minimumLinesNode,
          class: normalizeClass(unref(styles).DummyInput),
          innerHTML: contentsForMinimumLines.value
        }, null, 10, _hoisted_2)) : createCommentVNode("", true)
      ], 2);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Resizer.vue_vue_type_script_setup_true_lang.js.map
