import { defineComponent, mergeModels, useSlots, useModel, ref, computed, watch, onMounted, openBlock, createBlock, unref, createSlots, withCtx, createVNode, createElementVNode, normalizeClass, createElementBlock, renderSlot, createTextVNode, toDisplayString, createCommentVNode, Fragment, resolveDynamicComponent, h } from "vue";
import { u as useI18n } from "../../use/useI18n.js";
import { u as useId } from "../../use/useId.js";
import { u as useHasSlot } from "../../use/useHasSlot.js";
import { c as classNames, v as variationName } from "../../utilities/css.js";
import { K as Key } from "../../utilities/types.js";
import { u as useEventListener } from "../../utilities/use-event-listener.js";
import { h as helpTextID } from "../Labelled/utils.js";
import { l as labelId } from "../Label/utils.js";
import { _ as _sfc_main$5 } from "../Icon/Icon.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$1 } from "../Labelled/Labelled.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$4 } from "../Spinner/Spinner.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$3 } from "../Text/Text.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$2 } from "../Connected/Connected.vue_vue_type_script_setup_true_lang.js";
import { z as XCircleIcon } from "../../../vendor.js";
import { _ as _sfc_main$7 } from "./components/Resizer/Resizer.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$6 } from "./components/Spinner/Spinner.vue_vue_type_script_setup_true_lang.js";
const TextField = "Polaris-TextField";
const ClearButton = "Polaris-TextField__ClearButton";
const Loading = "Polaris-TextField__Loading";
const disabled = "Polaris-TextField--disabled";
const error = "Polaris-TextField--error";
const readOnly = "Polaris-TextField--readOnly";
const Input = "Polaris-TextField__Input";
const Backdrop = "Polaris-TextField__Backdrop";
const multiline = "Polaris-TextField--multiline";
const hasValue = "Polaris-TextField--hasValue";
const focus = "Polaris-TextField--focus";
const VerticalContent = "Polaris-TextField__VerticalContent";
const InputAndSuffixWrapper = "Polaris-TextField__InputAndSuffixWrapper";
const toneMagic = "Polaris-TextField--toneMagic";
const Prefix = "Polaris-TextField__Prefix";
const Suffix = "Polaris-TextField__Suffix";
const AutoSizeWrapper = "Polaris-TextField__AutoSizeWrapper";
const AutoSizeWrapperWithSuffix = "Polaris-TextField__AutoSizeWrapperWithSuffix";
const suggestion = "Polaris-TextField--suggestion";
const borderless = "Polaris-TextField--borderless";
const slim = "Polaris-TextField--slim";
const PrefixIcon = "Polaris-TextField__PrefixIcon";
const CharacterCount = "Polaris-TextField__CharacterCount";
const AlignFieldBottom = "Polaris-TextField__AlignFieldBottom";
const Spinner = "Polaris-TextField__Spinner";
const SpinnerIcon = "Polaris-TextField__SpinnerIcon";
const Resizer = "Polaris-TextField__Resizer";
const DummyInput = "Polaris-TextField__DummyInput";
const Segment = "Polaris-TextField__Segment";
const monospaced = "Polaris-TextField--monospaced";
const styles = {
  TextField,
  ClearButton,
  Loading,
  disabled,
  error,
  readOnly,
  Input,
  Backdrop,
  multiline,
  hasValue,
  focus,
  VerticalContent,
  InputAndSuffixWrapper,
  toneMagic,
  Prefix,
  Suffix,
  AutoSizeWrapper,
  AutoSizeWrapperWithSuffix,
  suggestion,
  borderless,
  slim,
  "Input-hasClearButton": "Polaris-TextField__Input--hasClearButton",
  "Input-suffixed": "Polaris-TextField__Input--suffixed",
  "Input-alignRight": "Polaris-TextField__Input--alignRight",
  "Input-alignLeft": "Polaris-TextField__Input--alignLeft",
  "Input-alignCenter": "Polaris-TextField__Input--alignCenter",
  "Input-autoSize": "Polaris-TextField__Input--autoSize",
  PrefixIcon,
  CharacterCount,
  AlignFieldBottom,
  Spinner,
  SpinnerIcon,
  Resizer,
  DummyInput,
  Segment,
  monospaced
};
const _hoisted_1 = ["id"];
const _hoisted_2 = ["data-auto-size-value"];
const _hoisted_3 = ["id"];
const _hoisted_4 = ["id"];
const _hoisted_5 = ["id"];
const _hoisted_6 = ["id"];
const _hoisted_7 = ["aria-label", "aria-live"];
const _hoisted_8 = ["id"];
const _hoisted_9 = ["disabled"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "TextField",
  props: /* @__PURE__ */ mergeModels({
    prefix: {},
    suffix: {},
    verticalContent: {},
    placeholder: {},
    value: {},
    helpText: {},
    label: {},
    labelAction: {},
    labelHidden: { type: Boolean },
    disabled: { type: Boolean },
    clearButton: { type: Boolean },
    selectTextOnFocus: { type: Boolean },
    suggestion: {},
    readOnly: { type: Boolean },
    autoFocus: { type: Boolean },
    focused: { type: Boolean },
    multiline: { type: [Boolean, Number] },
    error: { type: [String, Array, Boolean] },
    type: { default: "text" },
    name: {},
    id: {},
    role: {},
    step: {},
    largeStep: {},
    autoComplete: {},
    max: {},
    maxLength: {},
    maxHeight: {},
    min: {},
    minLength: {},
    pattern: {},
    inputMode: {},
    spellCheck: { type: Boolean },
    ariaOwns: {},
    ariaExpanded: { type: Boolean },
    ariaControls: {},
    ariaActiveDescendant: {},
    ariaAutocomplete: {},
    showCharacterCount: { type: Boolean },
    align: {},
    requiredIndicator: { type: Boolean },
    monospaced: { type: Boolean },
    variant: { default: "inherit" },
    size: { default: "medium" },
    tone: {},
    autoSize: { type: Boolean },
    loading: { type: Boolean },
    readonly: { type: Boolean }
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["clear-button-click", "input", "change", "spinner-change", "focus", "blur"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const slots = useSlots();
    const emits = __emit;
    const i18n = useI18n();
    const { hasSlot } = useHasSlot();
    const model = useModel(__props, "modelValue");
    const isAfterInitial = ref(false);
    const height = ref(null);
    const focus2 = ref(props.focused);
    const buttonPressTimer = ref();
    const uniqId = useId();
    const id = props.id || uniqId;
    const textFieldRef = ref(null);
    const inputRef = ref(null);
    const textAreaRef = ref(null);
    const prefixRef = ref(null);
    const suffixRef = ref(null);
    const loadingRef = ref(null);
    const verticalContentRef = ref(null);
    const spinnerRef = ref(null);
    const inputElm = computed(() => {
      return props.multiline ? textAreaRef.value : inputRef.value;
    });
    watch(
      () => [props.focused, props.verticalContent, inputElm.value],
      () => {
        if (!inputElm.value || !props.focused) return;
        if (props.focused) {
          inputElm.value.focus();
        } else {
          inputElm.value.blur();
        }
      },
      { immediate: true }
    );
    watch(
      () => [focus2.value, model.value, props.type, props.suggestion],
      () => {
        const isSupportedInputType = props.type === "text" || props.type === "tel" || props.type === "search" || props.type === "url" || props.type === "password";
        if (!inputRef.value || !isSupportedInputType || !props.suggestion || !model.value) return;
        inputRef.value.setSelectionRange(model.value.length, props.suggestion.length);
      },
      { flush: "post" }
    );
    onMounted(() => {
      isAfterInitial.value = true;
    });
    const hasLabel = computed(() => hasSlot(slots.label) || props.label);
    const hasHelpText = computed(() => hasSlot(slots.helpText) || props.helpText);
    const hasSuffix = computed(() => hasSlot(slots.suffix) || props.suffix);
    const hasPrefix = computed(() => hasSlot(slots.prefix) || props.prefix);
    const hasVerticalContent = computed(() => hasSlot(slots.verticalContent) || props.verticalContent);
    const normalizedValue = computed(() => props.suggestion ? props.suggestion : model.value);
    const normalizedStep = computed(() => {
      return props.step || 1;
    });
    const normalizedMax = computed(() => {
      return props.max || Infinity;
    });
    const normalizedMin = computed(() => {
      return props.min || -Infinity;
    });
    const className = computed(() => classNames(
      styles.TextField,
      Boolean(normalizedValue.value) && styles.hasValue,
      props.disabled && styles.disabled,
      props.readOnly && styles.readOnly,
      props.error && styles.error,
      props.tone && styles[variationName("tone", props.tone)],
      props.multiline && styles.multiline,
      focus2.value && !props.disabled && styles.focus,
      props.variant !== "inherit" && styles[props.variant],
      props.size === "slim" && styles.slim
    ));
    const inputType = computed(() => {
      return props.type === "currency" ? "text" : props.type;
    });
    const isNumericType = computed(() => {
      return props.type === "number" || props.type === "integer";
    });
    const clearButtonVisible = computed(() => normalizedValue.value !== "");
    const style = computed(() => {
      return props.multiline && height.value ? { height: `${height.value}px`, maxHeight: `${props.maxHeight}px` } : void 0;
    });
    const describedBy = computed(() => {
      const output = [];
      if (props.error) {
        output.push(`${id}Error`);
      }
      if (hasHelpText.value) {
        output.push(helpTextID(`${id}`));
      }
      if (props.showCharacterCount) {
        output.push(`${id}-CharacterCounter`);
      }
      return output;
    });
    const labelledBy = computed(() => {
      const output = [];
      if (hasPrefix.value) {
        output.push(`${id}-Prefix`);
      }
      if (hasSuffix.value) {
        output.push(`${id}-Suffix`);
      }
      if (hasVerticalContent.value) {
        output.push(`${id}-VerticalContent`);
      }
      output.unshift(labelId(`${id}`));
      return output;
    });
    const inputClassName = computed(() => classNames(
      styles.Input,
      props.align && styles[variationName("Input-align", props.align)],
      hasSuffix.value && styles["Input-suffixed"],
      props.clearButton && styles["Input-hasClearButton"],
      props.monospaced && styles.monospaced,
      props.suggestion && styles.suggestion,
      props.autoSize && styles["Input-autoSize"]
    ));
    const autoSizeClassName = computed(() => classNames(
      styles.AutoSizeWrapper,
      hasSuffix.value && styles.AutoSizeWrapperWithSuffix
    ));
    const characterCount = computed(() => {
      var _a;
      return (_a = normalizedValue.value) == null ? void 0 : _a.length;
    });
    const characterCountLabel = computed(() => {
      return props.maxLength ? i18n.translate("Polaris.TextField.characterCountWithMaxLength", {
        count: characterCount.value || 0,
        limit: props.maxLength
      }) : i18n.translate("Polaris.TextField.characterCount", {
        count: characterCount.value || 0
      });
    });
    const characterCountClassName = computed(() => classNames(
      styles.CharacterCount,
      props.multiline && styles.AlignFieldBottom
    ));
    const characterCountText = computed(
      () => !props.maxLength ? characterCount.value : `${characterCount.value}/${props.maxLength}`
    );
    const backdropClassName = computed(() => classNames(
      styles.Backdrop,
      slots.connectedLeft && styles["Backdrop-connectedLeft"],
      slots.connectedRight && styles["Backdrop-connectedRight"]
    ));
    const isIconPrefix = computed(() => {
      var _a;
      const prefixElm = slots.prefix && slots.prefix()[0];
      return (_a = prefixElm == null ? void 0 : prefixElm.type) == null ? void 0 : _a.__name;
    });
    const handleNumberChange = (steps, stepAmount = normalizedStep.value) => {
      const dpl = (num) => {
        const dec = String(num).split(".")[1];
        return dec ? dec.length : 0;
      };
      const numericValue = model.value ? parseFloat(model.value) : 0;
      if (isNaN(numericValue)) {
        return;
      }
      const decimalPlaces = props.type === "integer" ? 0 : Math.max(dpl(numericValue), dpl(stepAmount));
      const newValue = Math.min(
        Number(normalizedMax.value),
        Math.max(numericValue + steps * stepAmount, Number(normalizedMin.value))
      );
      model.value = String(newValue.toFixed(decimalPlaces));
      emits("spinner-change", model.value, `${id}`);
      emits("change", model.value, `${id}`);
    };
    const handleSpinnerButtonRelease = () => {
      if (buttonPressTimer.value) {
        clearInterval(buttonPressTimer.value);
      }
    };
    const handleSpinnerButtonPress = (step) => {
      const minInterval = 50;
      const decrementBy = 10;
      let interval = 200;
      const { handleStep } = spinnerRef.value || {};
      const onChangeInterval = () => {
        if (interval > minInterval) {
          interval -= decrementBy;
        }
        handleStep && handleStep(step);
        buttonPressTimer.value = window.setTimeout(onChangeInterval, interval);
      };
      buttonPressTimer.value = window.setTimeout(onChangeInterval, interval);
      document.addEventListener("mouseup", handleSpinnerButtonRelease, { once: true });
    };
    const handleExpandingResize = (heightValue) => {
      height.value = heightValue;
    };
    const handleOnFocus = (e) => {
      var _a;
      focus2.value = true;
      if (props.selectTextOnFocus && !props.suggestion) {
        (_a = inputElm.value) == null ? void 0 : _a.select();
      }
      emits("focus", e);
    };
    useEventListener("wheel", handleOnWheel, inputRef.value);
    function handleOnWheel(e) {
      if (document.activeElement === e.target && isNumericType.value) {
        e.stopPropagation();
      }
    }
    const input = () => h(props.multiline ? "textarea" : "input", {
      name: props.name,
      id: `${id}`,
      disabled: props.disabled,
      readOnly: props.readOnly,
      role: props.role,
      autoFocus: props.autoFocus ? props.autoFocus : void 0,
      value: normalizedValue.value || props.value,
      placeholder: props.placeholder,
      style: style.value,
      autoComplete: props.autoComplete,
      class: inputClassName.value,
      ref: props.multiline ? textAreaRef : inputRef,
      min: props.min,
      max: props.max,
      step: props.step,
      minLength: props.minLength,
      maxLength: props.maxLength,
      spellCheck: props.spellCheck,
      pattern: props.pattern,
      inputMode: props.inputMode,
      type: inputType.value,
      rows: getRows(props.multiline),
      size: props.autoSize ? 1 : void 0,
      "aria-describedby": describedBy.value.join(" "),
      "aria-labelledby": labelledBy.value.join(" "),
      "aria-invalid": Boolean(props.error),
      "aria-owns": props.ariaOwns,
      "aria-activedescendant": props.ariaActiveDescendant,
      "aria-autocomplete": props.ariaAutocomplete,
      "aria-controls": props.ariaControls,
      "aria-expanded": props.ariaExpanded,
      "aria-required": props.requiredIndicator,
      ...normalizeAriaMultiline(props.multiline),
      onFocus: handleOnFocus,
      onBlur: handleOnBlur,
      onClick: handleClickChild,
      onKeyPress: handleKeyPress,
      onKeyDown: handleKeyDown,
      onChange: !props.suggestion ? handleChange : void 0,
      onInput: handleInput,
      "data-1p-ignore": props.autoComplete === "off" || void 0,
      "data-lpignore": props.autoComplete === "off" || void 0,
      "data-form-type": props.autoComplete === "off" ? "other" : void 0
    });
    function handleChange(e) {
      emits("change", e.target.value, `${id}`);
    }
    function handleInput(e) {
      model.value = e.target.value;
      emits("input", e, e.target.value);
      if (props.suggestion) {
        e.target.value = props.suggestion;
        handleChange(e);
      }
    }
    function handleClick(e) {
      var _a, _b, _c;
      const { target } = e;
      if (!target) return;
      const inputRefRole = (_a = inputRef.value) == null ? void 0 : _a.getAttribute("role");
      if (target === inputRef.value && inputRefRole === "combobox") {
        (_b = inputRef.value) == null ? void 0 : _b.focus();
        handleOnFocus(e);
        return;
      }
      if (isPrefixOrSuffix(target) || isVerticalContent(target) || isInput(target) || isSpinner(target) || isLoadingSpinner(target) || focus2.value) {
        return;
      }
      (_c = inputElm.value) == null ? void 0 : _c.focus();
    }
    function handleClickChild(event) {
      var _a;
      if (!event.target) return;
      if (!isSpinner(event.target) && !isInput(event.target)) {
        event.stopPropagation();
      }
      if (isPrefixOrSuffix(event.target) || isVerticalContent(event.target) || isInput(event.target) || isLoadingSpinner(event.target) || focus2.value) {
        return;
      }
      focus2.value = true;
      (_a = inputElm.value) == null ? void 0 : _a.focus();
    }
    function handleClearButtonPress() {
      emits("clear-button-click", `${id}`);
    }
    function handleKeyPress(event) {
      const { key, which } = event;
      const numbersSpec = /[\d.,eE+-]$/;
      const integerSpec = /[\deE+-]$/;
      if (!isNumericType || which === Key.Enter || props.type === "number" && numbersSpec.test(key) || props.type === "integer" && integerSpec.test(key)) {
        return;
      }
      event.preventDefault();
    }
    function handleKeyDown(event) {
      if (!isNumericType) {
        return;
      }
      const { key, which } = event;
      if (props.type === "integer" && (key === "ArrowUp" || which === Key.UpArrow)) {
        handleNumberChange(1);
        event.preventDefault();
      }
      if (props.type === "integer" && (key === "ArrowDown" || which === Key.DownArrow)) {
        handleNumberChange(-1);
        event.preventDefault();
      }
      if ((which === Key.Home || key === "Home") && props.min) {
        model.value = String(props.min);
        emits("spinner-change", model.value, `${id}`);
        emits("change", model.value, `${id}`);
      }
      if ((which === Key.End || key === "End") && props.max !== void 0) {
        model.value = String(props.max);
        emits("spinner-change", model.value, `${id}`);
        emits("change", model.value, `${id}`);
      }
      if ((which === Key.PageUp || key === "PageUp") && props.largeStep !== void 0) {
        handleNumberChange(1, props.largeStep);
      }
      if ((which === Key.PageDown || key === "PageDown") && props.largeStep !== void 0) {
        handleNumberChange(-1, props.largeStep);
      }
    }
    function handleOnBlur(event) {
      var _a;
      focus2.value = false;
      if ((_a = textFieldRef.value) == null ? void 0 : _a.contains(event.relatedTarget)) {
        return;
      }
      emits("blur", event);
    }
    function isInput(target) {
      const input2 = inputElm.value;
      return target instanceof HTMLElement && input2 && (input2.contains(target) || input2.contains(document.activeElement));
    }
    function isPrefixOrSuffix(target) {
      return target instanceof Element && (prefixRef.value && prefixRef.value.contains(target) || suffixRef.value && suffixRef.value.contains(target));
    }
    function isSpinner(target) {
      const { spinnerWrapperRef } = spinnerRef.value || {};
      return target instanceof Element && spinnerWrapperRef && spinnerWrapperRef.contains(target);
    }
    function isLoadingSpinner(target) {
      return target instanceof Element && loadingRef.value && loadingRef.value.contains(target);
    }
    function isVerticalContent(target) {
      return target instanceof Element && verticalContentRef.value && (verticalContentRef.value.contains(target) || verticalContentRef.value.contains(document.activeElement));
    }
    function getRows(multiline2) {
      if (!multiline2) return void 0;
      return typeof multiline2 === "number" ? multiline2 : 1;
    }
    function normalizeAriaMultiline(multiline2) {
      if (!multiline2) return void 0;
      return Boolean(multiline2) || typeof multiline2 === "number" && multiline2 > 0 ? { "aria-multiline": true } : void 0;
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1), {
        id: `${unref(id)}`,
        error: _ctx.error,
        action: _ctx.labelAction,
        "label-hidden": _ctx.labelHidden,
        "required-indicator": _ctx.requiredIndicator,
        disabled: _ctx.disabled,
        "read-only": _ctx.readOnly
      }, createSlots({
        default: withCtx(() => [
          createVNode(unref(_sfc_main$2), null, createSlots({
            default: withCtx(() => [
              createElementVNode("div", {
                class: normalizeClass(className.value),
                onClick: handleClick,
                ref_key: "textFieldRef",
                ref: textFieldRef
              }, [
                hasPrefix.value ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(classNames)(unref(styles).Prefix, isIconPrefix.value && unref(styles).PrefixIcon)),
                  id: `${unref(id)}-Prefix`,
                  ref_key: "prefixRef",
                  ref: prefixRef
                }, [
                  unref(hasSlot)(slots.prefix) ? renderSlot(_ctx.$slots, "prefix", { key: 0 }) : (openBlock(), createBlock(unref(_sfc_main$3), {
                    key: 1,
                    as: "span",
                    variant: "bodyMd"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.prefix), 1)
                    ]),
                    _: 1
                  }))
                ], 10, _hoisted_1)) : createCommentVNode("", true),
                _ctx.autoSize ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(styles).InputAndSuffixWrapper)
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(autoSizeClassName.value),
                    "data-auto-size-value": model.value || _ctx.placeholder
                  }, [
                    hasVerticalContent.value ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(unref(styles).VerticalContent),
                      id: `${unref(id)}-VerticalContent`,
                      ref_key: "verticalContentRef",
                      ref: verticalContentRef,
                      onClick: handleClickChild
                    }, [
                      unref(hasSlot)(slots.verticalContent) ? renderSlot(_ctx.$slots, "verticalContent", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createTextVNode(toDisplayString(_ctx.verticalContent), 1)
                      ], 64)),
                      (openBlock(), createBlock(resolveDynamicComponent(input)))
                    ], 10, _hoisted_3)) : (openBlock(), createBlock(resolveDynamicComponent(input), { key: 1 }))
                  ], 10, _hoisted_2),
                  hasSuffix.value ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(styles).Suffix),
                    id: `${unref(id)}-Suffix`,
                    ref_key: "suffixRef",
                    ref: suffixRef
                  }, [
                    unref(hasSlot)(slots.suffix) ? renderSlot(_ctx.$slots, "suffix", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString(_ctx.suffix), 1)
                    ], 64))
                  ], 10, _hoisted_4)) : createCommentVNode("", true)
                ], 2)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  hasVerticalContent.value ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(styles).VerticalContent),
                    id: `${unref(id)}-VerticalContent`,
                    ref_key: "verticalContentRef",
                    ref: verticalContentRef,
                    onClick: handleClickChild
                  }, [
                    unref(hasSlot)(slots.verticalContent) ? renderSlot(_ctx.$slots, "verticalContent", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString(_ctx.verticalContent), 1)
                    ], 64)),
                    (openBlock(), createBlock(resolveDynamicComponent(input)))
                  ], 10, _hoisted_5)) : (openBlock(), createBlock(resolveDynamicComponent(input), { key: 1 })),
                  hasSuffix.value ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: normalizeClass(unref(styles).Suffix),
                    id: `${unref(id)}-Suffix`,
                    ref_key: "suffixRef",
                    ref: suffixRef
                  }, [
                    unref(hasSlot)(slots.suffix) ? renderSlot(_ctx.$slots, "suffix", { key: 0 }) : (openBlock(), createBlock(unref(_sfc_main$3), {
                      key: 1,
                      as: "span",
                      variant: "bodyMd"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.suffix), 1)
                      ]),
                      _: 1
                    }))
                  ], 10, _hoisted_6)) : createCommentVNode("", true)
                ], 64)),
                props.showCharacterCount ? (openBlock(), createElementBlock("div", {
                  key: 3,
                  class: normalizeClass(characterCountClassName.value),
                  "aria-label": characterCountLabel.value,
                  "aria-live": focus2.value ? "polite" : "off",
                  "aria-atomic": "true",
                  onClick: handleClickChild
                }, [
                  createVNode(unref(_sfc_main$3), {
                    as: "span",
                    variant: "bodyMd"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(characterCountText.value), 1)
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_7)) : createCommentVNode("", true),
                _ctx.loading ? (openBlock(), createElementBlock("div", {
                  key: 4,
                  class: normalizeClass(unref(styles).Loading),
                  id: `${unref(id)}-Loading`,
                  ref_key: "loadingRef",
                  ref: loadingRef
                }, [
                  createVNode(unref(_sfc_main$4), { size: "small" })
                ], 10, _hoisted_8)) : createCommentVNode("", true),
                _ctx.clearButton && clearButtonVisible.value ? (openBlock(), createElementBlock("button", {
                  key: 5,
                  type: "button",
                  class: normalizeClass(unref(styles).ClearButton),
                  disabled: _ctx.disabled,
                  onClick: handleClearButtonPress
                }, [
                  createVNode(unref(_sfc_main$3), {
                    as: "span",
                    "visually-hidden": ""
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref(i18n).translate("Polaris.Common.clear")), 1)
                    ]),
                    _: 1
                  }),
                  createVNode(unref(_sfc_main$5), {
                    source: unref(XCircleIcon),
                    tone: "base"
                  }, null, 8, ["source"])
                ], 10, _hoisted_9)) : createCommentVNode("", true),
                isNumericType.value && _ctx.step !== 0 && !_ctx.disabled && !_ctx.readOnly ? (openBlock(), createBlock(unref(_sfc_main$6), {
                  key: 6,
                  ref_key: "spinnerRef",
                  ref: spinnerRef,
                  onClick: handleClickChild,
                  onChange: handleNumberChange,
                  onMousedown: handleSpinnerButtonPress,
                  onMouseup: handleSpinnerButtonRelease,
                  onBlur: handleOnBlur
                }, null, 512)) : createCommentVNode("", true),
                createElementVNode("div", {
                  class: normalizeClass(backdropClassName.value)
                }, null, 2),
                _ctx.multiline && isAfterInitial.value ? (openBlock(), createBlock(unref(_sfc_main$7), {
                  key: 7,
                  contents: normalizedValue.value || _ctx.placeholder,
                  "current-height": height.value,
                  "minimum-lines": typeof _ctx.multiline === "number" ? _ctx.multiline : 1,
                  onHeightChange: handleExpandingResize
                }, null, 8, ["contents", "current-height", "minimum-lines"])) : createCommentVNode("", true)
              ], 2)
            ]),
            _: 2
          }, [
            Boolean(slots.connectedLeft) ? {
              name: "left",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "connectedLeft")
              ]),
              key: "0"
            } : void 0,
            Boolean(slots.connectedRight) ? {
              name: "right",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "connectedRight")
              ]),
              key: "1"
            } : void 0
          ]), 1024)
        ]),
        _: 2
      }, [
        hasLabel.value ? {
          name: "label",
          fn: withCtx(() => [
            unref(hasSlot)(slots.label) ? renderSlot(_ctx.$slots, "label", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ], 64))
          ]),
          key: "0"
        } : void 0,
        hasHelpText.value ? {
          name: "helpText",
          fn: withCtx(() => [
            unref(hasSlot)(slots.helpText) ? renderSlot(_ctx.$slots, "helpText", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.helpText), 1)
            ], 64))
          ]),
          key: "1"
        } : void 0
      ]), 1032, ["id", "error", "action", "label-hidden", "required-indicator", "disabled", "read-only"]);
    };
  }
});
export {
  _sfc_main as _,
  styles as s
};
//# sourceMappingURL=TextField.vue_vue_type_script_setup_true_lang.js.map
