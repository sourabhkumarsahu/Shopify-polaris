import { defineComponent, useSlots, ref, computed, watch, openBlock, createBlock, unref, withCtx, createElementBlock, Fragment, renderList, createVNode, createTextVNode, toDisplayString, createCommentVNode, mergeProps, renderSlot } from "vue";
import { u as useId } from "../../use/useId.js";
import { _ as _sfc_main$2 } from "../BlockStack/BlockStack.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$1 } from "../Box/Box.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$4 } from "./components/Option/Option.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$3 } from "../Text/Text.vue_vue_type_script_setup_true_lang.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "OptionList",
  props: {
    id: {},
    title: {},
    options: {},
    role: {},
    optionRole: {},
    sections: {},
    selected: {},
    allowMultiple: { type: Boolean },
    verticalAlign: {}
  },
  emits: ["change", "pointer-enter-option", "focus-option"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const uniqueId = useId();
    const normalizedOptions = ref(createNormalizedOptions(props.options, props.sections, props.title));
    const id = computed(() => props.id || String(uniqueId));
    const optionsExist = computed(() => normalizedOptions.value.length > 0);
    const handleClick = (sectionIndex, optionIndex) => {
      var _a, _b, _c, _d;
      const selectedValue = normalizedOptions.value[sectionIndex].options[optionIndex].value;
      const foundIndex = (_a = props.selected) == null ? void 0 : _a.indexOf(selectedValue);
      if (props.allowMultiple) {
        const newSelection = foundIndex === -1 ? [selectedValue, ...props.selected || []] : [
          ...((_b = props.selected) == null ? void 0 : _b.slice(0, foundIndex)) || [],
          ...((_d = props.selected) == null ? void 0 : _d.slice((foundIndex || 0) + 1, (_c = props.selected) == null ? void 0 : _c.length)) || []
        ];
        emits("change", newSelection);
        return;
      }
      emits("change", [selectedValue]);
    };
    const handlePointerEnter = (sectionIndex, optionIndex) => {
      const selectedValue = normalizedOptions.value[sectionIndex].options[optionIndex].value;
      emits("pointer-enter-option", selectedValue);
    };
    const handleFocus = (sectionIndex, optionIndex) => {
      const selectedValue = normalizedOptions.value[sectionIndex].options[optionIndex].value;
      emits("focus-option", selectedValue);
    };
    function createNormalizedOptions(options, sections, title) {
      if (!options || !options.length) {
        const section = title ? [{ options: [], title }] : [];
        return !sections || !sections.length ? [] : [...section, ...sections];
      }
      if (!sections || !sections.length) {
        return [
          {
            title,
            options
          }
        ];
      }
      return [
        {
          title,
          options
        },
        ...sections
      ];
    }
    watch(
      () => [props.options, props.sections, props.title],
      (newVal, oldVal) => {
        if (newVal !== oldVal) {
          normalizedOptions.value = createNormalizedOptions(props.options || [], props.sections || [], props.title);
        }
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1), {
        as: "ul",
        role: _ctx.role,
        padding: "150"
      }, {
        default: withCtx(() => [
          optionsExist.value ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(normalizedOptions.value, ({ title, options }, sectionIndex) => {
            return openBlock(), createBlock(unref(_sfc_main$1), {
              key: title || `noTitle-${sectionIndex}`,
              as: "li",
              "padding-block-start": sectionIndex === 0 ? title ? "100" : "0" : title ? "050" : "0"
            }, {
              default: withCtx(() => [
                createVNode(unref(_sfc_main$2), {
                  gap: sectionIndex === 0 && _ctx.sections ? void 0 : "0"
                }, {
                  default: withCtx(() => [
                    title ? (openBlock(), createBlock(unref(_sfc_main$1), {
                      key: 0,
                      "padding-block-start": sectionIndex === 0 ? "050" : "300",
                      "padding-inline-start": "150",
                      "padding-block-end": "100",
                      "padding-inline-end": "150",
                      "border-secondary": "border-secondary"
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(_sfc_main$3), {
                          as: sectionIndex === 0 ? "h2" : "h3",
                          variant: "headingSm"
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(title), 1)
                          ]),
                          _: 2
                        }, 1032, ["as"])
                      ]),
                      _: 2
                    }, 1032, ["padding-block-start"])) : createCommentVNode("", true),
                    createVNode(unref(_sfc_main$1), {
                      as: "ul",
                      id: `${id.value}-${sectionIndex}`,
                      role: _ctx.role
                    }, {
                      default: withCtx(() => [
                        options ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(options, (option, optionIndex) => {
                          return openBlock(), createBlock(unref(_sfc_main$4), mergeProps({ ref_for: true }, option, {
                            key: option.id || `${unref(uniqueId)}-${sectionIndex}-${optionIndex}`,
                            id: option.id || `${unref(uniqueId)}-${sectionIndex}-${optionIndex}`,
                            section: sectionIndex,
                            index: optionIndex,
                            select: _ctx.selected.includes(option.value),
                            "allow-multiple": _ctx.allowMultiple,
                            "vertical-align": _ctx.verticalAlign,
                            onClick: handleClick,
                            onPointerEnter: handlePointerEnter,
                            onFocus: handleFocus
                          }), {
                            label: withCtx(() => [
                              slots[`option-label-${option.id}`] ? renderSlot(_ctx.$slots, `option-label-${option.id}`, { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                createTextVNode(toDisplayString(option.label), 1)
                              ], 64))
                            ]),
                            _: 2
                          }, 1040, ["id", "section", "index", "select", "allow-multiple", "vertical-align"]);
                        }), 128)) : createCommentVNode("", true)
                      ]),
                      _: 2
                    }, 1032, ["id", "role"])
                  ]),
                  _: 2
                }, 1032, ["gap"])
              ]),
              _: 2
            }, 1032, ["padding-block-start"]);
          }), 128)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["role"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=OptionList.vue_vue_type_script_setup_true_lang.js.map
