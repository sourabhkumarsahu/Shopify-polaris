import { defineComponent, mergeModels, useSlots, useModel, ref, computed, openBlock, createBlock, unref, mergeProps, createSlots, withCtx, createElementVNode, normalizeClass, renderSlot, createElementBlock, Fragment, createTextVNode, toDisplayString } from "vue";
import { c as classNames, v as variationName } from "../../utilities/css.js";
import { _ as _sfc_main$1 } from "../Choice/Choice.vue_vue_type_script_setup_true_lang.js";
import { h as helpTextID } from "../Choice/utils.js";
import { u as useHasSlot } from "../../use/useHasSlot.js";
import { u as useId } from "../../use/useId.js";
const RadioButton = "Polaris-RadioButton";
const Input = "Polaris-RadioButton__Input";
const Backdrop = "Polaris-RadioButton__Backdrop";
const ChoiceLabel = "Polaris-RadioButton__ChoiceLabel";
const toneMagic = "Polaris-RadioButton--toneMagic";
const styles = {
  RadioButton,
  Input,
  Backdrop,
  ChoiceLabel,
  toneMagic
};
const _hoisted_1 = ["id", "name", "value", "checked", "disabled", "aria-describedby"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "RadioButton",
  props: /* @__PURE__ */ mergeModels({
    bleed: {},
    bleedBlockStart: {},
    bleedBlockEnd: {},
    bleedInlineStart: {},
    bleedInlineEnd: {},
    ariaDescribedBy: {},
    label: {},
    labelHidden: { type: Boolean },
    checked: { type: Boolean },
    disabled: { type: Boolean },
    id: {},
    name: {},
    value: {},
    fill: {},
    helpText: {},
    tone: {}
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["change", "focus", "blur"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const slots = useSlots();
    const emits = __emit;
    const { hasSlot } = useHasSlot();
    const uniqId = useId();
    const model = useModel(__props, "modelValue");
    const inputNode = ref(null);
    const id = computed(() => props.id ?? uniqId);
    const name = computed(() => props.name || id.value);
    const normalizedValue = computed(() => String(props.value ?? id.value));
    const ariaDescribedBy = computed(() => {
      const output = [];
      if (hasSlot(slots.helpText) || props.helpText) {
        output.push(helpTextID(`${id.value}`));
      }
      if (props.ariaDescribedBy) {
        output.push(props.ariaDescribedBy);
      }
      return output.length ? output.join(" ") : void 0;
    });
    const inputClassName = computed(() => classNames(
      styles.Input,
      props.tone && styles[variationName("tone", props.tone)]
    ));
    const extraChoiceProps = computed(() => ({
      bleed: props.bleed,
      bleedBlockStart: props.bleedBlockStart,
      bleedBlockEnd: props.bleedBlockEnd,
      bleedInlineStart: props.bleedInlineStart,
      bleedInlineEnd: props.bleedInlineEnd
    }));
    const handleBlur = () => {
      emits("blur");
    };
    const handleChange = (event) => {
      const target = event.target;
      model.value = normalizedValue.value;
      emits("change", target.checked, normalizedValue.value);
    };
    const handleFocus = () => {
      emits("focus");
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1), mergeProps({
        "label-hidden": _ctx.labelHidden,
        disabled: _ctx.disabled,
        id: `${id.value}`,
        "label-class-name": unref(styles).ChoiceLabel,
        fill: _ctx.fill,
        tone: model.value === normalizedValue.value ? _ctx.tone : void 0
      }, extraChoiceProps.value), createSlots({
        default: withCtx(() => [
          createElementVNode("span", {
            class: normalizeClass(unref(styles).RadioButton)
          }, [
            createElementVNode("input", {
              ref_key: "inputNode",
              ref: inputNode,
              id: `${id.value}`,
              name: `${name.value}`,
              value: _ctx.value,
              type: "radio",
              checked: _ctx.checked || model.value === normalizedValue.value,
              disabled: _ctx.disabled,
              class: normalizeClass(inputClassName.value),
              "aria-describedby": ariaDescribedBy.value,
              onChange: handleChange,
              onFocus: handleFocus,
              onBlur: handleBlur
            }, null, 42, _hoisted_1),
            createElementVNode("span", {
              class: normalizeClass(unref(styles).Backdrop)
            }, null, 2)
          ], 2)
        ]),
        _: 2
      }, [
        unref(hasSlot)(slots.label) || _ctx.label ? {
          name: "label",
          fn: withCtx(() => [
            unref(hasSlot)(slots.label) ? renderSlot(_ctx.$slots, "label", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ], 64))
          ]),
          key: "0"
        } : void 0,
        unref(hasSlot)(slots.helpText) || _ctx.helpText ? {
          name: "helpText",
          fn: withCtx(() => [
            unref(hasSlot)(slots.helpText) ? renderSlot(_ctx.$slots, "helpText", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.helpText), 1)
            ], 64))
          ]),
          key: "1"
        } : void 0
      ]), 1040, ["label-hidden", "disabled", "id", "label-class-name", "fill", "tone"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=RadioButton.vue_vue_type_script_setup_true_lang.js.map
