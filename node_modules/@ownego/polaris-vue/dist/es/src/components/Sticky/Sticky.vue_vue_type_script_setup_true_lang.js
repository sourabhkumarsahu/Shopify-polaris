import { defineComponent, useSlots, ref, onMounted, onBeforeUnmount, onUpdated, openBlock, createElementBlock, createElementVNode, normalizeStyle, renderSlot } from "vue";
import { u as useStickyManager } from "../../use/useStickyManager.js";
import { g as getRectForNode } from "../../utilities/geometry.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Sticky",
  props: {
    boundingElement: {},
    offset: { type: Boolean },
    disableWhenStacked: { type: Boolean }
  },
  emits: ["sticky-change"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    useSlots();
    const stickyManager = useStickyManager();
    const isSticky = ref(false);
    const style = ref({});
    const placeHolderNode = ref(null);
    const stickyNode = ref(null);
    onMounted(() => {
      if (!stickyNode.value || !placeHolderNode.value) {
        return;
      }
      stickyManager.value.registerStickyItem({
        stickyNode: stickyNode.value,
        placeHolderNode: placeHolderNode.value,
        handlePositioning,
        offset: props.offset,
        boundingElement: props.boundingElement,
        disableWhenStacked: props.disableWhenStacked
      });
    });
    onBeforeUnmount(() => {
      if (!stickyNode.value) {
        return;
      }
      stickyManager.value.unregisterStickyItem(stickyNode.value);
    });
    const handlePositioning = (stick, top = 0, left = 0, width = 0) => {
      if (stick && !isSticky.value || !stick && isSticky.value) {
        isSticky.value = !isSticky.value;
        emits("sticky-change", !isSticky.value);
        if (!props.boundingElement) {
          return;
        }
        adjustPlaceHolderNode(stick);
        props.boundingElement.toggleAttribute("data-sticky-active");
      }
      style.value = stick ? {
        position: "fixed",
        top: `${top}px`,
        left: `${left}px`,
        width: `${width}px`
      } : {};
    };
    const adjustPlaceHolderNode = (add) => {
      if (placeHolderNode.value && stickyNode.value) {
        placeHolderNode.value.style.paddingBottom = add ? `${getRectForNode(stickyNode.value).height}px` : "0px";
      }
    };
    const updateComponent = () => {
      const {
        boundingElement,
        offset,
        disableWhenStacked
      } = props;
      if (!stickyNode.value || !placeHolderNode.value) return;
      const stickyManagerItem = stickyManager.value.getStickyItem(stickyNode.value);
      const didPropsChange = !stickyManagerItem || boundingElement !== stickyManagerItem.boundingElement || offset !== stickyManagerItem.offset || disableWhenStacked !== stickyManagerItem.disableWhenStacked;
      if (!didPropsChange) return;
      stickyManager.value.unregisterStickyItem(stickyNode.value);
      stickyManager.value.registerStickyItem({
        stickyNode: stickyNode.value,
        placeHolderNode: placeHolderNode.value,
        handlePositioning,
        offset,
        boundingElement,
        disableWhenStacked
      });
    };
    onUpdated(() => {
      updateComponent();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("div", {
          ref_key: "placeHolderNode",
          ref: placeHolderNode
        }, null, 512),
        createElementVNode("div", {
          ref_key: "stickyNode",
          ref: stickyNode,
          style: normalizeStyle(style.value)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 4)
      ]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Sticky.vue_vue_type_script_setup_true_lang.js.map
