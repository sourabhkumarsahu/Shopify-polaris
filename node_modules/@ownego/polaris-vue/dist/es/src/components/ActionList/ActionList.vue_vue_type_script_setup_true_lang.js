import { defineComponent, ref, computed, openBlock, createElementBlock, Fragment, unref, createBlock, withCtx, createVNode, createCommentVNode, renderList } from "vue";
import { w as wrapFocusPreviousFocusableMenuItem, a as wrapFocusNextFocusableMenuItem } from "../../utilities/focus.js";
import { _ as _sfc_main$5 } from "./components/Section/Section.vue_vue_type_script_setup_true_lang.js";
import { S as SearchIcon } from "../../../vendor.js";
import { u as useFilterActions } from "../../use/useFilterActions.js";
import { u as useI18n } from "../../use/useI18n.js";
import { K as Key } from "../../utilities/types.js";
import { _ as _sfc_main$1 } from "../Box/Box.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$3 } from "../Icon/Icon.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$4 } from "../KeypressListener/KeypressListener.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$2 } from "../TextField/TextField.vue_vue_type_script_setup_true_lang.js";
const FILTER_ACTIONS_THRESHOLD = 8;
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "ActionList",
  props: {
    items: {},
    sections: {},
    actionRole: {},
    allowFiltering: { type: Boolean },
    filterLabel: {}
  },
  emits: ["action-any-item"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { filterActions } = useFilterActions();
    const i18n = useI18n();
    const searchText = ref("");
    const actionListRef = ref(null);
    const finalSections = computed(() => {
      if (props.items) {
        return [{ items: props.items }, ...props.sections || []];
      }
      if (props.sections) {
        return props.sections;
      }
      return [];
    });
    const isFilterable = computed(() => {
      var _a;
      return (_a = finalSections.value) == null ? void 0 : _a.some((section) => section.items.some((item) => typeof item.content === "string"));
    });
    const HasMultipleSections = computed(() => {
      var _a;
      return ((_a = finalSections.value) == null ? void 0 : _a.length) > 1 || false;
    });
    const elementRole = computed(() => HasMultipleSections.value && props.actionRole === "menuitem" ? "menu" : void 0);
    const elementTabIndex = computed(() => HasMultipleSections.value && props.actionRole === "menuitem" ? -1 : void 0);
    const filteredSections = computed(() => {
      var _a;
      return (_a = finalSections.value) == null ? void 0 : _a.map((section) => ({
        ...section,
        items: section.items.filter(
          ({ content }) => typeof content === "string" ? content == null ? void 0 : content.toLowerCase().includes(searchText.value.toLowerCase()) : content
        )
      }));
    });
    const totalActions = computed(
      () => {
        var _a;
        return ((_a = finalSections.value) == null ? void 0 : _a.reduce(
          (acc, section) => acc + section.items.length,
          0
        )) || 0;
      }
    );
    const totalFilteredActions = computed(() => {
      var _a;
      const totalSectionItems = ((_a = filteredSections.value) == null ? void 0 : _a.reduce(
        (acc, section) => acc + section.items.length,
        0
      )) || 0;
      return totalSectionItems;
    });
    const hasManyActions = computed(() => totalActions.value >= FILTER_ACTIONS_THRESHOLD);
    const setSearchText = (value) => {
      searchText.value = value;
    };
    const handleFocusPreviousItem = (evt) => {
      evt.preventDefault();
      if (actionListRef.value && evt.target) {
        if (actionListRef.value.contains(evt.target)) {
          wrapFocusPreviousFocusableMenuItem(
            actionListRef.value,
            evt.target
          );
        }
      }
    };
    const handleFocusNextItem = (evt) => {
      evt.preventDefault();
      if (actionListRef.value && evt.target) {
        if (actionListRef.value.contains(evt.target)) {
          wrapFocusNextFocusableMenuItem(
            actionListRef.value,
            evt.target
          );
        }
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        (_ctx.allowFiltering || unref(filterActions)) && hasManyActions.value && isFilterable.value ? (openBlock(), createBlock(unref(_sfc_main$1), {
          key: 0,
          padding: "200",
          "padding-block-end": totalFilteredActions.value > 0 ? "0" : "200"
        }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$2), {
              "clear-button": "",
              "label-hidden": "",
              label: _ctx.filterLabel || unref(i18n).translate("Polaris.ActionList.SearchField.placeholder"),
              placeholder: _ctx.filterLabel || unref(i18n).translate("Polaris.ActionList.SearchField.placeholder"),
              autoComplete: "off",
              modelValue: searchText.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchText.value = $event),
              onClearButtonClick: _cache[1] || (_cache[1] = () => setSearchText(""))
            }, {
              prefix: withCtx(() => [
                createVNode(unref(_sfc_main$3), { source: unref(SearchIcon) }, null, 8, ["source"])
              ]),
              _: 1
            }, 8, ["label", "placeholder", "modelValue"])
          ]),
          _: 1
        }, 8, ["padding-block-end"])) : createCommentVNode("", true),
        createVNode(unref(_sfc_main$1), {
          as: HasMultipleSections.value ? "ul" : "div",
          ref_key: "actionListRef",
          ref: actionListRef,
          role: elementRole.value,
          tabindex: elementTabIndex.value
        }, {
          default: withCtx(() => [
            _ctx.actionRole === "menuitem" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createVNode(unref(_sfc_main$4), {
                keyEvent: "keydown",
                keyCode: unref(Key).DownArrow,
                handler: handleFocusNextItem
              }, null, 8, ["keyCode"]),
              createVNode(unref(_sfc_main$4), {
                keyEvent: "keydown",
                keyCode: unref(Key).UpArrow,
                handler: handleFocusPreviousItem
              }, null, 8, ["keyCode"])
            ], 64)) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredSections.value, (section, index) => {
              return openBlock(), createElementBlock(Fragment, null, [
                section.items && section.items.length > 0 ? (openBlock(), createBlock(unref(_sfc_main$5), {
                  key: section.title || index,
                  section,
                  hasMultipleSections: HasMultipleSections.value,
                  actionRole: _ctx.actionRole,
                  onActionAnyItem: _cache[2] || (_cache[2] = ($event) => emits("action-any-item"))
                }, null, 8, ["section", "hasMultipleSections", "actionRole"])) : createCommentVNode("", true)
              ], 64);
            }), 256))
          ]),
          _: 1
        }, 8, ["as", "role", "tabindex"])
      ], 64);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=ActionList.vue_vue_type_script_setup_true_lang.js.map
