import { defineComponent, mergeModels, useSlots, useModel, ref, computed, watch, onMounted, openBlock, createBlock, unref, mergeProps, createSlots, withCtx, createElementVNode, normalizeClass, withModifiers, createElementBlock, renderSlot, Fragment, createTextVNode, toDisplayString } from "vue";
import { c as classNames, v as variationName } from "../../utilities/css.js";
import { u as useWithinListbox } from "../../use/useListbox.js";
import { u as useHasSlot } from "../../use/useHasSlot.js";
import { u as useId } from "../../use/useId.js";
import { h as helpTextID } from "../Choice/utils.js";
import { e as errorTextID } from "../InlineError/utils.js";
import { i as MinusIcon } from "../../../vendor.js";
import { _ as _sfc_main$1 } from "../Choice/Choice.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$2 } from "../Icon/Icon.vue_vue_type_script_setup_true_lang.js";
const Checkbox = "Polaris-Checkbox";
const ChoiceLabel = "Polaris-Checkbox__ChoiceLabel";
const Backdrop = "Polaris-Checkbox__Backdrop";
const Input = "Polaris-Checkbox__Input";
const Icon = "Polaris-Checkbox__Icon";
const animated = "Polaris-Checkbox--animated";
const toneMagic = "Polaris-Checkbox--toneMagic";
const hover = "Polaris-Checkbox--hover";
const error = "Polaris-Checkbox--error";
const checked = "Polaris-Checkbox--checked";
const pathAnimation = "Polaris-Checkbox--pathAnimation";
const styles = {
  Checkbox,
  ChoiceLabel,
  Backdrop,
  Input,
  "Input-indeterminate": "Polaris-Checkbox__Input--indeterminate",
  Icon,
  animated,
  toneMagic,
  hover,
  error,
  checked,
  pathAnimation
};
const _hoisted_1 = ["id", "name", "value", "checked", "disabled", "aria-invalid", "aria-controls", "aria-describedby", "role"];
const _hoisted_2 = {
  key: 1,
  viewBox: "0 0 16 16",
  "shape-rendering": "geometricPrecision",
  "text-rendering": "geometricPrecision"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Checkbox",
  props: /* @__PURE__ */ mergeModels({
    ariaControls: {},
    ariaDescribedBy: {},
    label: {},
    labelHidden: { type: Boolean },
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    id: {},
    name: {},
    value: {},
    labelClassName: {},
    fill: {},
    helpText: {},
    error: { type: [String, Array, Boolean] },
    tone: {},
    bleed: {},
    bleedBlockStart: {},
    bleedBlockEnd: {},
    bleedInlineStart: {},
    bleedInlineEnd: {}
  }, {
    "modelValue": { type: [Boolean, String] },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["change", "focus", "blur"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const slots = useSlots();
    const emits = __emit;
    const model = useModel(__props, "modelValue");
    const isWithinListbox = useWithinListbox();
    const uniqId = useId();
    const { hasSlot } = useHasSlot();
    __expose({
      focus: () => {
        if (inputNode.value) {
          inputNode.value.focus();
        }
      }
    });
    const inputNode = ref(null);
    const id = computed(() => props.id || `${uniqId}`);
    const describedBy = computed(() => {
      const output = [];
      if (props.error && typeof props.error !== "boolean") {
        output.push(errorTextID(id.value));
      }
      if (Boolean(slots.helpText) || props.helpText) {
        output.push(helpTextID(id.value));
      }
      if (props.ariaDescribedBy) {
        output.push(props.ariaDescribedBy);
      }
      return output;
    });
    const ariaDescribedBy = computed(
      () => describedBy.value.length ? describedBy.value.join(" ") : void 0
    );
    const wrapperClassName = computed(() => classNames(styles.Checkbox, props.error && styles.error));
    const isIndeterminate = computed(() => props.checked === "indeterminate");
    const isChecked = computed(() => Boolean(!isIndeterminate.value && model.value));
    const indeterminateAttributes = computed(
      () => isIndeterminate.value ? { indeterminate: true, "aria-checked": "mixed" } : { "aria-checked": isChecked.value }
    );
    const inputClassName = computed(() => classNames(
      styles.Input,
      isIndeterminate.value && styles["Input-indeterminate"],
      props.tone && styles[variationName("tone", props.tone)]
    ));
    const extraChoiceProps = computed(() => ({
      error: props.error,
      bleed: props.bleed,
      bleedBlockStart: props.bleedBlockStart,
      bleedBlockEnd: props.bleedBlockEnd,
      bleedInlineStart: props.bleedInlineStart,
      bleedInlineEnd: props.bleedInlineEnd
    }));
    const svgPathClassName = computed(() => classNames(isChecked.value && styles.checked));
    watch(
      () => props.checked,
      (value, oldVal) => {
        if (value === oldVal) return;
        model.value = value;
      },
      { flush: "post" }
    );
    onMounted(() => {
      if (props.checked) {
        model.value = props.checked;
      }
    });
    const handleBlur = () => {
      emits("blur");
    };
    const handleFocus = () => {
      emits("focus");
    };
    const handleOnClick = () => {
      if (!inputNode.value || props.disabled) {
        return;
      }
      model.value = inputNode.value.checked;
      inputNode.value.focus();
      emits("change", inputNode.value.checked, props.value || id.value);
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1), mergeProps({
        id: id.value,
        "label-hidden": _ctx.labelHidden,
        disabled: _ctx.disabled,
        "label-class-name": unref(classNames)(unref(styles).ChoiceLabel, _ctx.labelClassName),
        fill: _ctx.fill,
        tone: _ctx.tone
      }, extraChoiceProps.value), createSlots({
        default: withCtx(() => [
          createElementVNode("span", {
            class: normalizeClass(wrapperClassName.value)
          }, [
            createElementVNode("input", mergeProps({
              ref_key: "inputNode",
              ref: inputNode,
              type: "checkbox",
              id: id.value,
              name: _ctx.name,
              value: _ctx.value,
              checked: isChecked.value,
              disabled: _ctx.disabled,
              class: inputClassName.value,
              "aria-invalid": Boolean(_ctx.error),
              "aria-controls": _ctx.ariaControls,
              "aria-describedby": ariaDescribedBy.value,
              role: unref(isWithinListbox) ? "presentation" : "checkbox"
            }, indeterminateAttributes.value, {
              onBlur: handleBlur,
              onClick: handleOnClick,
              onFocus: handleFocus
            }), null, 16, _hoisted_1),
            createElementVNode("span", {
              class: normalizeClass(unref(styles).Backdrop),
              onClick: withModifiers(() => {
              }, ["stop"]),
              onKeyup: withModifiers(() => {
              }, ["stop"])
            }, null, 34),
            createElementVNode("span", {
              class: normalizeClass(unref(classNames)(unref(styles).Icon, !isIndeterminate.value && unref(styles).animated))
            }, [
              isIndeterminate.value ? (openBlock(), createBlock(unref(_sfc_main$2), {
                key: 0,
                source: unref(MinusIcon)
              }, null, 8, ["source"])) : (openBlock(), createElementBlock("svg", _hoisted_2, [
                createElementVNode("path", {
                  class: normalizeClass(svgPathClassName.value),
                  d: "M1.5,5.5L3.44655,8.22517C3.72862,8.62007,4.30578,8.64717,4.62362,8.28044L10.5,1.5",
                  transform: "translate(2 2.980376)",
                  opacity: "0",
                  fill: "none",
                  stroke: "currentColor",
                  "stroke-width": "2",
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  pathLength: "1"
                }, null, 2)
              ]))
            ], 2)
          ], 2)
        ]),
        _: 2
      }, [
        unref(hasSlot)(slots.label) || _ctx.label ? {
          name: "label",
          fn: withCtx(() => [
            unref(hasSlot)(slots.label) ? renderSlot(_ctx.$slots, "label", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(props.label), 1)
            ], 64))
          ]),
          key: "0"
        } : void 0,
        unref(hasSlot)(slots.helpText) || _ctx.helpText ? {
          name: "helpText",
          fn: withCtx(() => [
            unref(hasSlot)(slots.helpText) ? renderSlot(_ctx.$slots, "helpText", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(props.helpText), 1)
            ], 64))
          ]),
          key: "1"
        } : void 0
      ]), 1040, ["id", "label-hidden", "disabled", "label-class-name", "fill", "tone"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Checkbox.vue_vue_type_script_setup_true_lang.js.map
