import { defineComponent, getCurrentInstance, ref, reactive, computed, watch, openBlock, createElementBlock, normalizeClass, unref, createVNode, createElementVNode, Fragment, renderList, createBlock, mergeProps, withCtx, createTextVNode, toDisplayString } from "vue";
import { g as getVisibleAndHiddenActionsIndices } from "../../../../../polaris/polaris-react/src/components/ActionMenu/components/Actions/utilities.js";
import { u as useI18n } from "../../../../use/useI18n.js";
import { c as classNames } from "../../../../utilities/css.js";
import { _ as _sfc_main$1 } from "./components/ActionMeasurer/ActionsMeasurer.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$3 } from "../MenuGroup/MenuGroup.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$2 } from "../SecondaryAction/SecondaryAction.vue_vue_type_script_setup_true_lang.js";
const ActionsLayoutOuter = "Polaris-ActionMenu-Actions__ActionsLayoutOuter";
const ActionsLayout = "Polaris-ActionMenu-Actions__ActionsLayout";
const ActionsLayoutMeasurer = "Polaris-ActionMenu-Actions__ActionsLayoutMeasurer";
const styles = {
  ActionsLayoutOuter,
  ActionsLayout,
  "ActionsLayout--measuring": "Polaris-ActionMenu-Actions--actionsLayoutMeasuring",
  ActionsLayoutMeasurer
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Actions",
  props: {
    actions: {},
    groups: {}
  },
  emits: ["action-rollup"],
  setup(__props, { emit: __emit }) {
    const i18n = useI18n();
    const currentInstance = getCurrentInstance();
    const props = __props;
    const emits = __emit;
    const rollupActiveRef = ref(null);
    const activeMenuGroup = ref(null);
    const defaultRollupGroup = ref({
      title: i18n.translate("Polaris.ActionMenu.Actions.moreActions"),
      actions: []
    });
    const state = reactive({
      disclosureWidth: 0,
      containerWidth: Infinity,
      actionsWidths: [],
      visibleActions: [],
      hiddenActions: [],
      visibleGroups: [],
      hiddenGroups: [],
      hasMeasured: false
    });
    const classname = computed(() => classNames(
      styles.ActionsLayout,
      !state.hasMeasured && styles["ActionsLayout--measuring"]
    ));
    const getSecondaryActionProps = (index) => {
      var _a;
      return (_a = props.actions) == null ? void 0 : _a[index];
    };
    const handleMenuGroupToggle = (group) => {
      if (activeMenuGroup.value) {
        activeMenuGroup.value = null;
      } else {
        activeMenuGroup.value = group;
      }
    };
    const handleMenuGroupClose = () => {
      activeMenuGroup.value = null;
    };
    const actionsOrDefault = computed(() => props.actions ?? []);
    const groupsOrDefault = computed(() => props.groups ?? []);
    const groupsToFilter = computed(
      () => state.hiddenGroups.length > 0 || state.hiddenActions.length > 0 ? [...groupsOrDefault.value, defaultRollupGroup.value] : [...groupsOrDefault.value]
    );
    const filteredGroups = computed(
      () => groupsToFilter.value.filter((group, index) => {
        const hasNoGroupsProp = groupsOrDefault.value.length === 0;
        const isVisibleGroup = state.visibleGroups.includes(index);
        const isDefaultGroup = group.title === defaultRollupGroup.value.title && group.actions.length === 0;
        if (hasNoGroupsProp) {
          return state.hiddenActions.length > 0;
        }
        if (isDefaultGroup) {
          return true;
        }
        return isVisibleGroup;
      })
    );
    const actionsFilter = computed(
      () => actionsOrDefault.value.filter((_, index) => {
        if (!state.visibleActions.includes(index)) {
          return false;
        }
        return true;
      })
    );
    const hiddenActionObjects = computed(
      () => state.hiddenActions.map((index) => actionsOrDefault.value[index]).filter((action) => action != null)
    );
    const hiddenGroupObjects = computed(
      () => state.hiddenGroups.map((index) => groupsOrDefault.value[index]).filter((group) => group != null)
    );
    const finalRolledUp = computed(() => {
      const allHiddenItems = [...hiddenActionObjects.value, ...hiddenGroupObjects.value];
      return allHiddenItems.reduce(
        ([actions, sections], action) => {
          if (isMenuGroup(action)) {
            sections.push({
              title: action.title,
              items: action.actions.map((sectionAction) => ({
                ...sectionAction,
                disabled: action.disabled || sectionAction.disabled
              }))
            });
          } else {
            actions.push(action);
          }
          return [actions, sections];
        },
        [[], []]
      );
    });
    const finalRolledUpActions = computed(() => {
      return finalRolledUp.value[0];
    });
    const finalRolledUpSectionGroups = computed(() => finalRolledUp.value[1]);
    const menuGroupProps = (group) => {
      const { actions, ...rest } = group;
      return {
        ...rest,
        active: activeMenuGroup.value === group.title,
        sections: finalRolledUpSectionGroups.value
      };
    };
    const getMenuGroupActions = (group) => {
      const isDefaultGroup = group === defaultRollupGroup.value;
      if (!isDefaultGroup) {
        return group.actions;
      }
      return [...finalRolledUpActions.value, ...group.actions];
    };
    const handleMeasurement = (measurements) => {
      var _a;
      const {
        hiddenActionsWidths: actionsWidths,
        containerWidth,
        disclosureWidth
      } = measurements;
      const { visibleActions, hiddenActions, visibleGroups, hiddenGroups } = getVisibleAndHiddenActionsIndices(
        actionsOrDefault.value,
        groupsOrDefault.value,
        disclosureWidth,
        actionsWidths,
        containerWidth
      );
      if ((_a = currentInstance == null ? void 0 : currentInstance.vnode.props) == null ? void 0 : _a.onActionRollup) {
        const isRollupActive = hiddenActions.length > 0 || hiddenGroups.length > 0;
        if (rollupActiveRef.value !== isRollupActive) {
          emits("action-rollup", isRollupActive);
          rollupActiveRef.value = isRollupActive;
        }
      }
      state.visibleActions = visibleActions;
      state.hiddenActions = hiddenActions;
      state.visibleGroups = visibleGroups;
      state.hiddenGroups = hiddenGroups;
      state.actionsWidths = actionsWidths;
      state.containerWidth = containerWidth;
      state.disclosureWidth = disclosureWidth;
      state.hasMeasured = true;
    };
    watch(
      () => [
        state.containerWidth,
        state.disclosureWidth,
        props.actions,
        props.groups,
        state.actionsWidths
      ],
      () => {
        if (state.containerWidth === 0) {
          return;
        }
        const { visibleActions, visibleGroups, hiddenActions, hiddenGroups } = getVisibleAndHiddenActionsIndices(
          props.actions,
          props.groups,
          state.disclosureWidth,
          state.actionsWidths,
          state.containerWidth
        );
        state.visibleActions = visibleActions;
        state.visibleGroups = visibleGroups;
        state.hiddenActions = hiddenActions;
        state.hiddenGroups = hiddenGroups;
        state.hasMeasured = state.containerWidth !== Infinity;
      },
      {
        immediate: true
      }
    );
    const isMenuGroup = (actionOrMenuGroup) => {
      return "title" in actionOrMenuGroup;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(styles).ActionsLayoutOuter)
      }, [
        createVNode(unref(_sfc_main$1), {
          actions: _ctx.actions,
          groups: _ctx.groups,
          onMeasurements: handleMeasurement
        }, null, 8, ["actions", "groups"]),
        createElementVNode("div", {
          class: normalizeClass(classname.value)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(actionsFilter.value, (action, index) => {
            return openBlock(), createBlock(unref(_sfc_main$2), mergeProps({ ref_for: true }, getSecondaryActionProps(index), {
              key: action.content,
              onClick: ($event) => {
                var _a;
                return ((_a = action.onAction) == null ? void 0 : _a.call(action)) || void 0;
              }
            }), {
              default: withCtx(() => [
                createTextVNode(toDisplayString(action.content), 1)
              ]),
              _: 2
            }, 1040, ["onClick"]);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(filteredGroups.value, (group) => {
            return openBlock(), createBlock(unref(_sfc_main$3), mergeProps({ ref_for: true }, menuGroupProps(group), {
              key: group.title,
              title: group.title,
              actions: getMenuGroupActions(group),
              onOpen: handleMenuGroupToggle,
              onClose: handleMenuGroupClose
            }), null, 16, ["title", "actions"]);
          }), 128))
        ], 2)
      ], 2);
    };
  }
});
export {
  _sfc_main as _,
  styles as s
};
//# sourceMappingURL=Actions.vue_vue_type_script_setup_true_lang.js.map
