import { defineComponent, useSlots, computed, openBlock, createElementBlock, mergeProps, unref, normalizeClass, createElementVNode, createVNode, renderSlot, Fragment, createBlock, withCtx } from "vue";
import { u as useI18n } from "../../../../use/useI18n.js";
import { c as classNames, v as variationName } from "../../../../utilities/css.js";
import { h as headerCell } from "../../../../../polaris/polaris-react/src/components/shared.js";
import { _ as _sfc_main$2 } from "./TruncatedText.vue_vue_type_script_setup_true_lang.js";
import { k as SortDescendingIcon, l as SortAscendingIcon } from "../../../../../vendor.js";
import { s as styles } from "../../DataTable.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$1 } from "../../../Icon/Icon.vue_vue_type_script_setup_true_lang.js";
const _hoisted_1 = ["aria-sort"];
const _hoisted_2 = ["tabindex"];
const _hoisted_3 = ["aria-sort"];
const _hoisted_4 = ["tabindex"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Cell",
  props: {
    contentType: {},
    nthColumn: { type: Boolean },
    firstColumn: { type: Boolean },
    truncate: { type: Boolean },
    header: { type: Boolean },
    total: { type: Boolean },
    totalInFooter: { type: Boolean },
    sorted: { type: Boolean },
    sortable: { type: Boolean },
    sortDirection: {},
    defaultSortDirection: { default: "ascending" },
    verticalAlign: { default: "top" },
    colSpan: {},
    style: {},
    setRef: {},
    stickyHeadingCell: { type: Boolean, default: false },
    stickyCellWidth: {},
    hovered: { type: Boolean, default: false },
    inFixedNthColumn: { type: Boolean },
    hasFixedNthColumn: { type: Boolean, default: false },
    fixedCellVisible: { type: Boolean, default: false },
    firstColumnMinWidth: {},
    lastFixedFirstColumn: { type: Boolean }
  },
  emits: ["sort", "focus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useSlots();
    const emits = __emit;
    const i18n = useI18n();
    const numeric = computed(() => props.contentType === "numeric");
    const className = computed(() => classNames(
      styles.Cell,
      styles[`Cell-${variationName("verticalAlign", props.verticalAlign)}`],
      props.firstColumn && styles["Cell-firstColumn"],
      props.truncate && styles["Cell-truncated"],
      props.header && styles["Cell-header"],
      props.total && styles["Cell-total"],
      props.totalInFooter && styles["Cell-total-footer"],
      numeric.value && styles["Cell-numeric"],
      props.sortable && styles["Cell-sortable"],
      props.sorted && styles["Cell-sorted"],
      props.stickyHeadingCell && styles.StickyHeaderCell,
      props.hovered && styles["Cell-hovered"],
      props.lastFixedFirstColumn && props.inFixedNthColumn && props.fixedCellVisible && styles["Cell-separate"],
      props.nthColumn && props.inFixedNthColumn && props.stickyHeadingCell && styles.FixedFirstColumn
    ));
    const headerClassName = computed(() => classNames(
      props.header && styles.Heading,
      props.header && props.contentType === "text" && styles["Heading-left"]
    ));
    const iconClassName = computed(() => classNames(props.sortable && styles.Icon));
    const direction = computed(() => props.sorted && props.sortDirection ? props.sortDirection : props.defaultSortDirection);
    const source = computed(() => direction.value === "descending" ? SortDescendingIcon : SortAscendingIcon);
    const oppositeDirection = computed(() => props.sortDirection === "ascending" ? "descending" : "ascending");
    const sortAccessibilityLabel = computed(() => i18n.translate(
      "Polaris.DataTable.sortAccessibilityLabel",
      { direction: props.sorted ? oppositeDirection.value : direction.value }
    ));
    const focusable = computed(() => !(props.stickyHeadingCell && props.hasFixedNthColumn && props.nthColumn && !props.inFixedNthColumn));
    const colSpanProp = computed(() => props.colSpan && props.colSpan > 1 ? { colSpan: props.colSpan } : {});
    const minWidthStyles = computed(() => props.nthColumn && props.firstColumnMinWidth ? { minWidth: `${props.firstColumnMinWidth}px` } : { minWidth: `${props.stickyCellWidth}px` });
    const handleFocus = (e) => {
      emits("focus", e);
    };
    return (_ctx, _cache) => {
      return _ctx.stickyHeadingCell ? (openBlock(), createElementBlock("th", mergeProps({
        key: 0,
        ref: _ctx.setRef
      }, { ...unref(headerCell).props, ...colSpanProp.value }, {
        class: className.value,
        "aria-sort": _ctx.sortDirection,
        style: { ...props.style, ...minWidthStyles.value },
        "data-index-table-sticky-heading": ""
      }), [
        _ctx.sortable ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: normalizeClass(headerClassName.value),
          tabindex: focusable.value ? 0 : -1,
          onClick: _cache[0] || (_cache[0] = ($event) => emits("sort")),
          onFocus: handleFocus
        }, [
          createElementVNode("span", {
            class: normalizeClass(iconClassName.value)
          }, [
            createVNode(unref(_sfc_main$1), {
              source: source.value,
              accessibilityLabel: sortAccessibilityLabel.value
            }, null, 8, ["source", "accessibilityLabel"])
          ], 2),
          renderSlot(_ctx.$slots, "default")
        ], 42, _hoisted_2)) : renderSlot(_ctx.$slots, "default", { key: 1 })
      ], 16, _hoisted_1)) : _ctx.header || _ctx.firstColumn || _ctx.nthColumn ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.header ? (openBlock(), createElementBlock("th", mergeProps({
          key: 0,
          ref: _ctx.setRef
        }, { ...unref(headerCell).props, ...colSpanProp.value }, {
          class: className.value,
          "aria-sort": _ctx.sortDirection,
          scope: "col",
          style: { ...minWidthStyles.value }
        }), [
          _ctx.sortable ? (openBlock(), createElementBlock("button", {
            key: 0,
            class: normalizeClass(headerClassName.value),
            tabindex: focusable.value ? 0 : -1,
            onClick: _cache[1] || (_cache[1] = ($event) => emits("sort")),
            onFocus: handleFocus
          }, [
            createElementVNode("span", {
              class: normalizeClass(iconClassName.value)
            }, [
              createVNode(unref(_sfc_main$1), {
                source: source.value,
                accessibilityLabel: sortAccessibilityLabel.value
              }, null, 8, ["source", "accessibilityLabel"])
            ], 2),
            renderSlot(_ctx.$slots, "default")
          ], 42, _hoisted_4)) : renderSlot(_ctx.$slots, "default", { key: 1 })
        ], 16, _hoisted_3)) : (openBlock(), createElementBlock("th", mergeProps({
          key: 1,
          ref: _ctx.setRef
        }, { ...colSpanProp.value }, {
          class: className.value,
          scope: "row",
          style: { ...minWidthStyles.value }
        }), [
          _ctx.truncate ? (openBlock(), createBlock(_sfc_main$2, {
            key: 0,
            className: unref(styles).TooltipContent
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["className"])) : renderSlot(_ctx.$slots, "default", { key: 1 })
        ], 16))
      ], 64)) : (openBlock(), createElementBlock("td", mergeProps({
        key: 2,
        class: className.value
      }, colSpanProp.value), [
        renderSlot(_ctx.$slots, "default")
      ], 16));
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Cell.vue_vue_type_script_setup_true_lang.js.map
