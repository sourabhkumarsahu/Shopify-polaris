import { defineComponent, ref, computed, onMounted, onBeforeUnmount, openBlock, createElementBlock, normalizeClass, unref, createVNode, withCtx, createElementVNode, createBlock, resolveDynamicComponent, createCommentVNode, Fragment, renderList, normalizeStyle, mergeProps, createTextVNode, toDisplayString, h, toRaw } from "vue";
import { d as debounce } from "../../../polaris/polaris-react/src/utilities/debounce.js";
import { c as classNames } from "../../utilities/css.js";
import { u as useI18n } from "../../use/useI18n.js";
import { h as headerCell } from "../../../polaris/polaris-react/src/components/shared.js";
import { m as measureColumn, g as getPrevAndCurrentColumns } from "../../../polaris/polaris-react/src/components/DataTable/utilities.js";
import { _ as _sfc_main$5 } from "./components/Cell/Cell.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$4 } from "./components/Navigation/Navigation.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$2 } from "../EventListener/EventListener.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$3 } from "../Pagination/Pagination.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$1 } from "../Sticky/Sticky.vue_vue_type_script_setup_true_lang.js";
const DataTable = "Polaris-DataTable";
const condensed = "Polaris-DataTable--condensed";
const Navigation = "Polaris-DataTable__Navigation";
const Pip = "Polaris-DataTable__Pip";
const ScrollContainer = "Polaris-DataTable__ScrollContainer";
const Table = "Polaris-DataTable__Table";
const TableRow = "Polaris-DataTable__TableRow";
const Cell = "Polaris-DataTable__Cell";
const IncreasedTableDensity = "Polaris-DataTable__IncreasedTableDensity";
const ZebraStripingOnData = "Polaris-DataTable__ZebraStripingOnData";
const RowCountIsEven = "Polaris-DataTable__RowCountIsEven";
const ShowTotalsInFooter = "Polaris-DataTable__ShowTotalsInFooter";
const hoverable = "Polaris-DataTable--hoverable";
const Icon = "Polaris-DataTable__Icon";
const Heading = "Polaris-DataTable__Heading";
const StickyHeaderEnabled = "Polaris-DataTable__StickyHeaderEnabled";
const StickyHeaderWrapper = "Polaris-DataTable__StickyHeaderWrapper";
const ShowTotals = "Polaris-DataTable__ShowTotals";
const Footer = "Polaris-DataTable__Footer";
const StickyHeaderInner = "Polaris-DataTable__StickyHeaderInner";
const StickyHeaderTable = "Polaris-DataTable__StickyHeaderTable";
const FixedFirstColumn = "Polaris-DataTable__FixedFirstColumn";
const StickyTableHeadingsRow = "Polaris-DataTable__StickyTableHeadingsRow";
const TooltipContent = "Polaris-DataTable__TooltipContent";
const styles = {
  DataTable,
  condensed,
  Navigation,
  Pip,
  "Pip-visible": "Polaris-DataTable__Pip--visible",
  ScrollContainer,
  Table,
  TableRow,
  Cell,
  IncreasedTableDensity,
  ZebraStripingOnData,
  RowCountIsEven,
  ShowTotalsInFooter,
  "Cell-separate": "Polaris-DataTable__Cell--separate",
  "Cell-firstColumn": "Polaris-DataTable__Cell--firstColumn",
  "Cell-numeric": "Polaris-DataTable__Cell--numeric",
  "Cell-truncated": "Polaris-DataTable__Cell--truncated",
  "Cell-header": "Polaris-DataTable__Cell--header",
  "Cell-sortable": "Polaris-DataTable__Cell--sortable",
  "Heading-left": "Polaris-DataTable__Heading--left",
  "Cell-verticalAlignTop": "Polaris-DataTable__Cell--verticalAlignTop",
  "Cell-verticalAlignBottom": "Polaris-DataTable__Cell--verticalAlignBottom",
  "Cell-verticalAlignMiddle": "Polaris-DataTable__Cell--verticalAlignMiddle",
  "Cell-verticalAlignBaseline": "Polaris-DataTable__Cell--verticalAlignBaseline",
  hoverable,
  "Cell-hovered": "Polaris-DataTable__Cell--hovered",
  Icon,
  Heading,
  StickyHeaderEnabled,
  StickyHeaderWrapper,
  "Cell-sorted": "Polaris-DataTable__Cell--sorted",
  "Cell-total": "Polaris-DataTable__Cell--total",
  ShowTotals,
  "Cell-total-footer": "Polaris-DataTable--cellTotalFooter",
  Footer,
  StickyHeaderInner,
  "StickyHeaderInner-isSticky": "Polaris-DataTable__StickyHeaderInner--isSticky",
  StickyHeaderTable,
  FixedFirstColumn,
  StickyTableHeadingsRow,
  TooltipContent
};
const _hoisted_1 = { key: 0 };
const _hoisted_2 = { key: 0 };
const _hoisted_3 = { key: 0 };
const _hoisted_4 = { key: 0 };
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "DataTable",
  props: {
    columnContentTypes: {},
    headings: {},
    totals: {},
    totalsName: {},
    showTotalsInFooter: { type: Boolean },
    rows: {},
    hideScrollIndicator: { type: Boolean, default: false },
    truncate: { type: Boolean },
    verticalAlign: {},
    footerContent: { type: [String, Number, Boolean, Function, Object, null] },
    hoverable: { type: Boolean, default: true },
    sortable: {},
    defaultSortDirection: {},
    initialSortColumnIndex: { default: 0 },
    increasedTableDensity: { type: Boolean, default: false },
    hasZebraStripingOnData: { type: Boolean, default: false },
    stickyHeader: { type: Boolean, default: false },
    hasFixedFirstColumn: { type: Boolean },
    fixedFirstColumns: {},
    firstColumnMinWidth: {},
    pagination: {}
  },
  emits: ["sort"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const i18n = useI18n();
    const isMounted = ref(false);
    const condensed2 = ref(false);
    const columnVisibilityData = ref([]);
    const previousColumn = ref(void 0);
    const currentColumn = ref(void 0);
    const sortedColumnIndex = ref(void 0);
    const sortDirection = ref(void 0);
    const isScrolledFarthestLeft = ref(true);
    const isScrolledFarthestRight = ref(false);
    const rowHovered = ref();
    const dataTable = ref(null);
    const scrollContainer = ref(null);
    const table = ref(null);
    const stickyTable = ref(null);
    const stickyNav = ref(null);
    const headerNav = ref(null);
    const tableHeadings = ref([]);
    const stickyHeadings = ref([]);
    const tableHeadingWidths = ref([]);
    const stickyHeaderActive = ref(false);
    const scrollStopTimer = ref(null);
    const handleResize = debounce(() => {
      let tmpCondensed = false;
      if (table.value && scrollContainer.value) {
        tmpCondensed = table.value.scrollWidth > scrollContainer.value.clientWidth + 1;
      }
      calculateColumnVisibilityData(tmpCondensed);
      condensed2.value = tmpCondensed;
    }, 40, { trailing: true, leading: true, maxWait: 40 });
    const fixedFirstColumns = computed(() => {
      const numberOfFixedFirstColumns = props.hasFixedFirstColumn && !props.fixedFirstColumns ? 1 : props.fixedFirstColumns || 0;
      if (numberOfFixedFirstColumns >= props.headings.length) {
        return 0;
      }
      return numberOfFixedFirstColumns;
    });
    const rowCountIsEven = computed(() => props.rows.length % 2 === 0);
    const className = computed(() => classNames(
      styles.DataTable,
      condensed2.value && styles.condensed,
      props.totals && styles.ShowTotals,
      props.showTotalsInFooter && styles.ShowTotalsInFooter,
      props.hasZebraStripingOnData && styles.ZebraStripingOnData,
      props.hasZebraStripingOnData && rowCountIsEven.value && styles.RowCountIsEven
    ));
    const wrapperClassName = computed(() => classNames(
      styles.TableWrapper,
      condensed2.value && styles.condensed,
      props.increasedTableDensity && styles.IncreasedTableDensity,
      props.stickyHeader && styles.StickyHeaderEnabled
    ));
    const nthColumns = computed(() => props.rows.map((row) => row.slice(0, fixedFirstColumns.value)));
    const nthHeadings = computed(() => props.headings.slice(0, fixedFirstColumns.value));
    const nthTotals = computed(() => {
      var _a;
      return (_a = props.totals) == null ? void 0 : _a.slice(0, fixedFirstColumns.value);
    });
    const tableHeaderRows = computed(() => {
      var _a;
      return (_a = table.value) == null ? void 0 : _a.children[0].childNodes;
    });
    const tableBodyRows = computed(() => {
      var _a;
      return (_a = table.value) == null ? void 0 : _a.children[1].childNodes;
    });
    const headerRowHeights = computed(() => getRowClientHeights(tableHeaderRows.value));
    const bodyRowHeights = computed(() => getRowClientHeights(tableBodyRows.value));
    const fixedFirstColumnClassName = computed(() => classNames(
      styles.FixedFirstColumn,
      !isScrolledFarthestLeft.value && styles.separate
    ));
    const tableRowClassName = computed(() => classNames(
      styles.TableRow,
      props.hoverable && styles.hoverable
    ));
    const stickyHeaderInnerClassNames = computed(() => classNames(
      styles.StickyHeaderInner,
      stickyHeaderActive.value && styles["StickyHeaderInner-isSticky"]
    ));
    const stickyHeaderTableClassNames = computed(() => classNames(
      styles.StickyHeaderTable,
      !isScrolledFarthestLeft.value && styles.separate
    ));
    const totalsRowHeading = computed(() => {
      const totalsLabel = props.totalsName ? props.totalsName : {
        singular: i18n.translate("Polaris.DataTable.totalRowHeading"),
        plural: i18n.translate("Polaris.DataTable.totalsRowHeading")
      };
      return props.totals && props.totals.filter((total) => total !== "").length > 1 ? totalsLabel.plural : totalsLabel.singular;
    });
    onMounted(() => {
      isMounted.value = true;
      handleResize();
    });
    onBeforeUnmount(() => {
      handleResize.cancel();
    });
    const getRowClientHeights = (rows) => {
      const heights = [];
      if (!rows) {
        return heights;
      }
      rows.forEach((row) => {
        heights.push(row.clientHeight);
      });
      return heights;
    };
    const setCellRef = ({
      cellRef,
      index,
      inStickyHeader
    }) => {
      if (!cellRef) {
        return;
      }
      if (inStickyHeader) {
        stickyHeadings.value[index] = cellRef;
        const button = cellRef.querySelector("button");
        if (!button) {
          return;
        }
        button.addEventListener("focus", handleHeaderButtonFocus);
      } else {
        tableHeadings.value[index] = cellRef;
        tableHeadingWidths.value[index] = cellRef.clientWidth;
      }
    };
    const changeHeadingFocus = () => {
      var _a, _b;
      const stickyFocusedItemIndex = stickyHeadings.value.findIndex(
        (item) => {
          var _a2;
          return item === ((_a2 = document.activeElement) == null ? void 0 : _a2.parentElement);
        }
      );
      const tableFocusedItemIndex = tableHeadings.value.findIndex(
        (item) => {
          var _a2;
          return item === ((_a2 = document.activeElement) == null ? void 0 : _a2.parentElement);
        }
      );
      const arrowsInStickyNav = (_a = stickyNav.value) == null ? void 0 : _a.querySelectorAll("button");
      const arrowsInHeaderNav = (_b = headerNav.value) == null ? void 0 : _b.querySelectorAll("button");
      let stickyFocusedNavIndex = -1;
      arrowsInStickyNav == null ? void 0 : arrowsInStickyNav.forEach((item, index) => {
        if (item === document.activeElement) {
          stickyFocusedNavIndex = index;
        }
      });
      let headerFocusedNavIndex = -1;
      arrowsInHeaderNav == null ? void 0 : arrowsInHeaderNav.forEach((item, index) => {
        if (item === document.activeElement) {
          headerFocusedNavIndex = index;
        }
      });
      if (stickyFocusedItemIndex < 0 && tableFocusedItemIndex < 0 && stickyFocusedNavIndex < 0 && headerFocusedNavIndex < 0) {
        return null;
      }
      let button;
      if (stickyFocusedItemIndex >= 0) {
        button = tableHeadings.value[stickyFocusedItemIndex].querySelector("button");
      } else if (tableFocusedItemIndex >= 0) {
        button = stickyHeadings.value[tableFocusedItemIndex].querySelector("button");
      }
      if (stickyFocusedNavIndex >= 0) {
        button = arrowsInHeaderNav == null ? void 0 : arrowsInHeaderNav[stickyFocusedNavIndex];
      } else if (headerFocusedNavIndex >= 0) {
        button = arrowsInStickyNav == null ? void 0 : arrowsInStickyNav[headerFocusedNavIndex];
      }
      if (!button) {
        return null;
      }
      button.style.visibility = "visible";
      button.focus();
      button.style.removeProperty("visibility");
    };
    const calculateColumnVisibilityData = (tmpCondensed) => {
      if ((props.stickyHeader || tmpCondensed) && table.value && scrollContainer.value && dataTable.value) {
        const headerCells = table.value.querySelectorAll(
          headerCell.selector
        );
        const rightMostHeader = headerCells[fixedFirstColumns.value - 1];
        const nthColumnWidth = fixedFirstColumns.value ? rightMostHeader.offsetLeft + rightMostHeader.offsetWidth : 0;
        if (headerCells.length > 0) {
          const firstVisibleColumnIndex = headerCells.length - 1;
          const tableLeftVisibleEdge = scrollContainer.value.scrollLeft + nthColumnWidth;
          const tableRightVisibleEdge = scrollContainer.value.scrollLeft + dataTable.value.offsetWidth;
          const tableData = {
            firstVisibleColumnIndex,
            tableLeftVisibleEdge,
            tableRightVisibleEdge
          };
          const tmpColumnVisibilityData = [...headerCells].map(
            measureColumn(tableData)
          );
          const lastColumn = tmpColumnVisibilityData[tmpColumnVisibilityData.length - 1];
          const tmpIsScrolledFarthestLeft = fixedFirstColumns.value ? tableLeftVisibleEdge === nthColumnWidth : tableLeftVisibleEdge === 0;
          const {
            previousColumn: tmpPreviousColumn,
            currentColumn: tmpCurrentColumn
          } = getPrevAndCurrentColumns(tableData, tmpColumnVisibilityData);
          columnVisibilityData.value = tmpColumnVisibilityData;
          isScrolledFarthestLeft.value = tmpIsScrolledFarthestLeft;
          isScrolledFarthestRight.value = lastColumn.rightEdge <= tableRightVisibleEdge;
          previousColumn.value = tmpPreviousColumn;
          currentColumn.value = tmpCurrentColumn;
          return;
        }
      }
      columnVisibilityData.value = [];
      previousColumn.value = void 0;
      currentColumn.value = void 0;
    };
    const handleHeaderButtonFocus = (event) => {
      var _a;
      if (!scrollContainer.value || event.target == null || columnVisibilityData.value.length === 0) {
        return;
      }
      const target = event.target;
      const currentCell = target.parentNode;
      const tableScrollLeft = scrollContainer.value.scrollLeft;
      const tableViewableWidth = scrollContainer.value.offsetWidth;
      const tableRightEdge = tableScrollLeft + tableViewableWidth;
      const nthColumnWidth = columnVisibilityData.value.length > 0 ? (_a = columnVisibilityData.value[fixedFirstColumns.value]) == null ? void 0 : _a.rightEdge : 0;
      const currentColumnLeftEdge = currentCell.offsetLeft;
      const currentColumnRightEdge = currentCell.offsetLeft + currentCell.offsetWidth;
      if (tableScrollLeft > currentColumnLeftEdge - nthColumnWidth) {
        scrollContainer.value.scrollLeft = currentColumnLeftEdge - nthColumnWidth;
      }
      if (currentColumnRightEdge > tableRightEdge) {
        scrollContainer.value.scrollLeft = currentColumnRightEdge - tableViewableWidth;
      }
    };
    const stickyHeaderScrolling = () => {
      if (!stickyTable.value || !scrollContainer.value) {
        return;
      }
      stickyTable.value.scrollLeft = scrollContainer.value.scrollLeft;
    };
    const scrollListener = () => {
      var _a, _b;
      if (scrollStopTimer.value) {
        clearTimeout(scrollStopTimer.value);
      }
      scrollStopTimer.value = setTimeout(() => {
        calculateColumnVisibilityData(condensed2.value);
      }, 100);
      if (isScrolledFarthestLeft.value !== (((_a = scrollContainer.value) == null ? void 0 : _a.scrollLeft) === 0)) {
        isScrolledFarthestLeft.value = ((_b = scrollContainer.value) == null ? void 0 : _b.scrollLeft) === 0;
      }
      if (props.stickyHeader && stickyHeaderActive.value) {
        stickyHeaderScrolling();
      }
    };
    const handleHover = (row) => () => {
      rowHovered.value = row;
    };
    const handleFocus = (event) => {
      var _a;
      if (!scrollContainer.value || !event.target) {
        return;
      }
      const currentCell = event.target.parentNode;
      const hasFixedFirstColumn = columnVisibilityData.value.length > 0;
      const nthColumnWidth = hasFixedFirstColumn ? (_a = columnVisibilityData.value[fixedFirstColumns.value]) == null ? void 0 : _a.rightEdge : 0;
      const currentColumnLeftEdge = currentCell.offsetLeft;
      const desiredScrollLeft = currentColumnLeftEdge - nthColumnWidth;
      if (scrollContainer.value.scrollLeft > desiredScrollLeft) {
        scrollContainer.value.scrollLeft = desiredScrollLeft;
      }
    };
    const navigateTable = (direction) => {
      var _a;
      const nthColumnWidth = (_a = columnVisibilityData.value[fixedFirstColumns.value - 1]) == null ? void 0 : _a.rightEdge;
      if (!currentColumn.value || !previousColumn.value) {
        return;
      }
      let prevWidths = 0;
      for (let index = 0; index < currentColumn.value.index; index++) {
        prevWidths += columnVisibilityData.value[index].width;
      }
      const handleScroll = () => {
        var _a2, _b, _c, _d;
        let newScrollLeft = 0;
        if (fixedFirstColumns.value) {
          newScrollLeft = direction === "right" ? prevWidths - nthColumnWidth + (((_a2 = currentColumn.value) == null ? void 0 : _a2.width) ?? 0) : prevWidths - (((_b = previousColumn.value) == null ? void 0 : _b.width) ?? 0) - nthColumnWidth;
        } else {
          newScrollLeft = direction === "right" ? ((_c = currentColumn.value) == null ? void 0 : _c.rightEdge) ?? 0 : ((_d = previousColumn.value) == null ? void 0 : _d.leftEdge) ?? 0;
        }
        if (scrollContainer.value) {
          scrollContainer.value.scrollLeft = newScrollLeft;
          requestAnimationFrame(() => {
            calculateColumnVisibilityData(condensed2.value);
          });
        }
      };
      return handleScroll;
    };
    const getColSpan = (rowLength, headingsLength, contentTypesLength, cellIndex) => {
      if (fixedFirstColumns.value) {
        return 1;
      }
      const rowLen = rowLength ? rowLength : 1;
      const colLen = headingsLength ? headingsLength : contentTypesLength;
      const colSpan = Math.floor(colLen / rowLen);
      const remainder = colLen % rowLen;
      return cellIndex === 0 ? colSpan + remainder : colSpan;
    };
    const defaultOnSort = (headingIndex) => {
      sortDirection.value = sortDirection.value ?? toRaw(props.defaultSortDirection || "ascending");
      sortedColumnIndex.value = sortedColumnIndex.value ?? toRaw(props.initialSortColumnIndex);
      let newSortDirection = props.defaultSortDirection || "ascending";
      if (sortedColumnIndex.value === headingIndex) {
        newSortDirection = sortDirection.value === "ascending" ? "descending" : "ascending";
      }
      const handleSort = () => {
        sortDirection.value = newSortDirection;
        sortedColumnIndex.value = headingIndex;
        emits("sort", headingIndex, newSortDirection);
      };
      return handleSort;
    };
    const stickyHandler = (isSticky) => {
      setTimeout(changeHeadingFocus, 10);
      stickyHeaderActive.value = isSticky;
    };
    const navigationMarkup = (location) => h(
      _sfc_main$4,
      {
        columnVisibilityData: columnVisibilityData.value,
        isScrolledFarthestLeft: isScrolledFarthestLeft.value,
        isScrolledFarthestRight: isScrolledFarthestRight.value,
        onNavigateTableLeft: navigateTable("left"),
        onNavigateTableRight: navigateTable("right"),
        fixedFirstColumns: fixedFirstColumns.value,
        setRef: (ref2) => {
          if (location === "sticky") {
            stickyNav.value = ref2;
          } else {
            headerNav.value = ref2;
          }
        }
      }
    );
    const renderHeading = ({
      heading,
      headingIndex,
      inFixedNthColumn,
      inStickyHeader
    }) => {
      sortDirection.value = sortDirection.value ?? props.defaultSortDirection;
      sortedColumnIndex.value = sortedColumnIndex.value ?? (props.initialSortColumnIndex || 0);
      let sortableHeadingProps;
      const headingCellId = `heading-cell-${headingIndex}`;
      const stickyHeaderId = `stickyheader-${headingIndex}`;
      const id = inStickyHeader ? stickyHeaderId : headingCellId;
      if (props.sortable) {
        const isSortable = props.sortable[headingIndex];
        const isSorted = isSortable && sortedColumnIndex.value === headingIndex;
        const direction = isSorted ? sortDirection.value : "none";
        sortableHeadingProps = {
          defaultSortDirection: props.defaultSortDirection,
          sorted: isSorted,
          sortable: isSortable,
          sortDirection: direction,
          inFixedNthColumn: fixedFirstColumns.value,
          onSort: defaultOnSort(headingIndex)
        };
      }
      const stickyCellWidth = inStickyHeader ? tableHeadingWidths.value[headingIndex] : void 0;
      const fixedCellVisible = !isScrolledFarthestLeft.value;
      const cellProps = {
        header: true,
        stickyHeadingCell: inStickyHeader,
        contentType: props.columnContentTypes[headingIndex],
        nthColumn: headingIndex < fixedFirstColumns.value,
        truncate: props.truncate,
        ...sortableHeadingProps,
        verticalAlign: props.verticalAlign,
        stickyCellWidth,
        fixedCellVisible,
        firstColumnMinWidth: props.firstColumnMinWidth,
        onFocus: handleFocus
      };
      if (inFixedNthColumn && inStickyHeader) {
        return () => {
          var _a;
          return [
            h(_sfc_main$5, {
              key: id,
              ...cellProps,
              setRef: (ref2) => {
                setCellRef({ cellRef: ref2, index: headingIndex, inStickyHeader });
              },
              inFixedNthColumn: false
            }, () => heading),
            h(_sfc_main$5, {
              key: `${id}-sticky`,
              ...cellProps,
              setRef: (ref2) => {
                setCellRef({ cellRef: ref2, index: headingIndex, inStickyHeader });
              },
              inFixedNthColumn: Boolean(fixedFirstColumns.value),
              lastFixedFirstColumn: headingIndex === fixedFirstColumns.value - 1,
              style: { left: `${(_a = columnVisibilityData.value[headingIndex]) == null ? void 0 : _a.leftEdge}px` }
            }, () => heading)
          ];
        };
      }
      return () => h(_sfc_main$5, {
        key: id,
        ...cellProps,
        setRef: (ref2) => {
          setCellRef({ cellRef: ref2, index: headingIndex, inStickyHeader });
        },
        inFixedNthColumn,
        lastFixedFirstColumn: headingIndex === fixedFirstColumns.value - 1
      }, () => heading);
    };
    const renderTotals = ({ total, index }) => {
      const id = `totals-cell-${index}`;
      let content;
      let contentType;
      if (!index) {
        content = totalsRowHeading.value;
      }
      if (total !== "" && index > 0) {
        content = total;
        contentType = props.columnContentTypes[index];
      }
      return () => h(_sfc_main$5, {
        key: id,
        total: true,
        totalInFooter: props.showTotalsInFooter,
        nthColumn: index <= fixedFirstColumns.value - 1,
        firstColumn: !index,
        contentType,
        truncate: props.truncate,
        verticalAlign: props.verticalAlign
      }, () => content);
    };
    const defaultRenderRow = ({
      row,
      index,
      inFixedNthColumn,
      rowHeights
    }) => {
      return () => h(
        "tr",
        {
          key: `row-${index}`,
          class: tableRowClassName.value,
          onMouseenter: handleHover(index),
          onMouseleave: handleHover()
        },
        row.map((content, cellIndex) => {
          const hovered = rowHovered.value === index;
          const id = `cell-${cellIndex}-row-${index}`;
          const colSpan = getColSpan(row.length, props.headings.length, props.columnContentTypes.length, cellIndex);
          return h(_sfc_main$5, {
            key: id,
            contentType: props.columnContentTypes[cellIndex],
            nthColumn: cellIndex <= fixedFirstColumns.value - 1,
            firstColumn: cellIndex === 0,
            truncate: props.truncate,
            verticalAlign: props.verticalAlign,
            colSpan,
            hovered,
            inFixedNthColumn: condensed2.value && inFixedNthColumn,
            style: { height: rowHeights ? `${rowHeights == null ? void 0 : rowHeights[index]}px` : void 0 }
          }, () => content);
        })
      );
    };
    return (_ctx, _cache) => {
      var _a;
      return openBlock(), createElementBlock("div", {
        ref_key: "dataTable",
        ref: dataTable,
        class: normalizeClass(wrapperClassName.value)
      }, [
        _ctx.stickyHeader && isMounted.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          role: "presentation",
          class: normalizeClass(unref(styles).StickyHeaderWrapper)
        }, [
          createVNode(unref(_sfc_main$1), {
            "bounding-element": dataTable.value,
            onStickyChange: stickyHandler
          }, {
            default: withCtx(() => [
              createElementVNode("div", {
                class: normalizeClass(stickyHeaderInnerClassNames.value)
              }, [
                createElementVNode("div", null, [
                  !_ctx.hideScrollIndicator ? (openBlock(), createBlock(resolveDynamicComponent(navigationMarkup("sticky")), { key: 0 })) : createCommentVNode("", true)
                ]),
                createElementVNode("table", {
                  ref_key: "stickyTable",
                  ref: stickyTable,
                  class: normalizeClass(stickyHeaderTableClassNames.value)
                }, [
                  createElementVNode("thead", null, [
                    createElementVNode("tr", {
                      class: normalizeClass(unref(styles).StickyTableHeadingsRow)
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.headings, (heading, headingIndex) => {
                        return openBlock(), createBlock(resolveDynamicComponent(renderHeading({ heading, headingIndex, inFixedNthColumn: Boolean(fixedFirstColumns.value && headingIndex <= fixedFirstColumns.value - 1), inStickyHeader: true })), { key: headingIndex });
                      }), 128))
                    ], 2)
                  ])
                ], 2)
              ], 2)
            ]),
            _: 1
          }, 8, ["bounding-element"])
        ], 2)) : createCommentVNode("", true),
        !_ctx.hideScrollIndicator ? (openBlock(), createBlock(resolveDynamicComponent(navigationMarkup("header")), { key: 1 })) : createCommentVNode("", true),
        createElementVNode("div", {
          class: normalizeClass(className.value)
        }, [
          createElementVNode("div", {
            ref_key: "scrollContainer",
            ref: scrollContainer,
            class: normalizeClass(unref(styles).ScrollContainer)
          }, [
            createVNode(unref(_sfc_main$2), {
              event: "resize",
              handler: unref(handleResize)
            }, null, 8, ["handler"]),
            createVNode(unref(_sfc_main$2), {
              event: "scroll",
              capture: "",
              passive: "",
              handler: scrollListener
            }),
            createElementVNode("table", {
              class: normalizeClass(fixedFirstColumnClassName.value),
              style: normalizeStyle({ width: `${(_a = columnVisibilityData.value[fixedFirstColumns.value - 1]) == null ? void 0 : _a.rightEdge}px` })
            }, [
              createElementVNode("thead", null, [
                createElementVNode("tr", {
                  style: normalizeStyle({ height: `${headerRowHeights.value[0]}px` })
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(nthHeadings.value, (heading, headingIndex) => {
                    return openBlock(), createBlock(resolveDynamicComponent(renderHeading({ heading, headingIndex, inFixedNthColumn: true, inStickyHeader: false })), { key: headingIndex });
                  }), 128))
                ], 4),
                _ctx.totals && !_ctx.showTotalsInFooter ? (openBlock(), createElementBlock("tr", {
                  key: 0,
                  style: normalizeStyle({ height: `${headerRowHeights.value[1]}px` })
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(nthTotals.value, (total, index) => {
                    return openBlock(), createBlock(resolveDynamicComponent(renderTotals({ total, index })), { key: index });
                  }), 128))
                ], 4)) : createCommentVNode("", true)
              ]),
              createElementVNode("tbody", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(nthColumns.value, (row, index) => {
                  return openBlock(), createBlock(resolveDynamicComponent(defaultRenderRow({ row, index, inFixedNthColumn: true, rowHeights: bodyRowHeights.value })));
                }), 256))
              ]),
              _ctx.totals && _ctx.showTotalsInFooter ? (openBlock(), createElementBlock("tfoot", _hoisted_1, [
                createElementVNode("tr", null, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(nthTotals.value, (total, index) => {
                    return openBlock(), createBlock(resolveDynamicComponent(renderTotals({ total, index })));
                  }), 256))
                ])
              ])) : createCommentVNode("", true)
            ], 6),
            createElementVNode("table", {
              ref_key: "table",
              ref: table,
              class: normalizeClass(unref(styles).Table)
            }, [
              createElementVNode("thead", null, [
                createElementVNode("tr", null, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.headings, (heading, headingIndex) => {
                    return openBlock(), createBlock(resolveDynamicComponent(renderHeading({ heading, headingIndex, inFixedNthColumn: false, inStickyHeader: false })));
                  }), 256))
                ]),
                !_ctx.showTotalsInFooter && _ctx.totals ? (openBlock(), createElementBlock("tr", _hoisted_2, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.totals, (total, index) => {
                    return openBlock(), createBlock(resolveDynamicComponent(renderTotals({ total, index })));
                  }), 256))
                ])) : createCommentVNode("", true)
              ]),
              createElementVNode("tbody", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row, index) => {
                  return openBlock(), createBlock(resolveDynamicComponent(defaultRenderRow({ row, index, inFixedNthColumn: false })));
                }), 256))
              ]),
              _ctx.showTotalsInFooter ? (openBlock(), createElementBlock("tfoot", _hoisted_3, [
                _ctx.totals ? (openBlock(), createElementBlock("tr", _hoisted_4, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.totals, (total, index) => {
                    return openBlock(), createBlock(resolveDynamicComponent(renderTotals({ total, index })));
                  }), 256))
                ])) : createCommentVNode("", true)
              ])) : createCommentVNode("", true)
            ], 2)
          ], 2),
          _ctx.pagination ? (openBlock(), createBlock(unref(_sfc_main$3), mergeProps({
            key: 0,
            type: "table"
          }, _ctx.pagination), null, 16)) : createCommentVNode("", true),
          _ctx.footerContent ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(unref(styles).Footer)
          }, [
            typeof _ctx.footerContent === "string" || typeof _ctx.footerContent === "number" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(_ctx.footerContent), 1)
            ], 64)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.footerContent), { key: 1 }))
          ], 2)) : createCommentVNode("", true)
        ], 2)
      ], 2);
    };
  }
});
export {
  _sfc_main as _,
  styles as s
};
//# sourceMappingURL=DataTable.vue_vue_type_script_setup_true_lang.js.map
