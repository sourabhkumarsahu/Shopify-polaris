import { defineComponent, mergeModels, useSlots, useModel, computed, openBlock, createBlock, unref, createSlots, withCtx, createElementVNode, normalizeClass, createElementBlock, Fragment, renderList, mergeProps, toDisplayString, createVNode, renderSlot, createTextVNode, createCommentVNode, resolveDynamicComponent } from "vue";
import { c as classNames, v as variationName } from "../../utilities/css.js";
import { u as useHasSlot } from "../../use/useHasSlot.js";
import { u as useId } from "../../use/useId.js";
import { _ as _sfc_main$2 } from "../Box/Box.vue_vue_type_script_setup_true_lang.js";
import { u as useToggle } from "../../use/useToggle.js";
import { e as SelectIcon } from "../../../vendor.js";
import { _ as _sfc_main$4 } from "../Icon/Icon.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$1 } from "../Labelled/Labelled.vue_vue_type_script_setup_true_lang.js";
import { h as helpTextID } from "../Labelled/utils.js";
import { _ as _sfc_main$3 } from "../Text/Text.vue_vue_type_script_setup_true_lang.js";
const Select = "Polaris-Select";
const disabled = "Polaris-Select--disabled";
const error = "Polaris-Select--error";
const Backdrop = "Polaris-Select__Backdrop";
const Input = "Polaris-Select__Input";
const Content = "Polaris-Select__Content";
const InlineLabel = "Polaris-Select__InlineLabel";
const Icon = "Polaris-Select__Icon";
const SelectedOption = "Polaris-Select__SelectedOption";
const Prefix = "Polaris-Select__Prefix";
const hover = "Polaris-Select--hover";
const toneMagic = "Polaris-Select--toneMagic";
const styles = {
  Select,
  disabled,
  error,
  Backdrop,
  Input,
  Content,
  InlineLabel,
  Icon,
  SelectedOption,
  Prefix,
  hover,
  toneMagic
};
const _hoisted_1 = ["id", "name", "value", "disabled", "aria-invalid", "aria-describedby", "aria-required"];
const _hoisted_2 = ["label"];
const _hoisted_3 = ["value", "disabled"];
const _hoisted_4 = ["value", "disabled"];
const _hoisted_5 = ["aria-disabled"];
const PLACEHOLDER_VALUE = "";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Select",
  props: /* @__PURE__ */ mergeModels({
    options: {},
    label: {},
    labelAction: {},
    labelHidden: { type: Boolean },
    labelInline: { type: Boolean },
    disabled: { type: Boolean },
    helpText: {},
    placeholder: {},
    id: {},
    name: {},
    value: {},
    error: { type: [String, Array, Boolean] },
    requiredIndicator: { type: Boolean },
    tone: {}
  }, {
    "modelValue": {
      default: PLACEHOLDER_VALUE
    },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["change", "focus", "blur"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const slots = useSlots();
    const emits = __emit;
    const model = useModel(__props, "modelValue");
    const {
      value: focused,
      toggle: toggleFocused
    } = useToggle(false);
    const { hasSlot } = useHasSlot();
    const uniqId = useId();
    const id = computed(() => props.id || uniqId);
    const labelHidden = computed(() => props.labelInline ? true : props.labelHidden);
    const className = computed(() => classNames(
      styles.Select,
      props.error && styles.error,
      props.tone && styles[variationName("tone", props.tone)],
      props.disabled && styles.disabled
    ));
    const hasLabel = computed(() => hasSlot(slots.label) || props.label);
    const hasHelpText = computed(() => hasSlot(slots.helpText) || props.helpText);
    const ariaDescribedBy = computed(() => {
      const describedBy = [];
      if (hasHelpText.value) {
        describedBy.push(helpTextID(`${id.value}`));
      }
      if (props.error) {
        describedBy.push(`${id.value}Error`);
      }
      return describedBy.length ? describedBy.join(" ") : void 0;
    });
    const optionsMarkup = computed(() => {
      return normalizedOptions.value.map((opt) => normalizeOption(opt));
    });
    const normalizedOptions = computed(() => {
      let options = (props.options || []).map(normalizeOption);
      if (props.placeholder) {
        options = [
          {
            value: PLACEHOLDER_VALUE,
            label: props.placeholder,
            disabled: true
          },
          ...options
        ];
      }
      return options;
    });
    const selectedOption = computed(() => {
      let selected = flattenOptions.value.find((option) => model.value === option.value);
      if (!selected) {
        selected = flattenOptions.value.find((option) => !option.hidden);
      }
      return selected || { value: "", label: "" };
    });
    const flattenOptions = computed(() => {
      let flatOptions = [];
      normalizedOptions.value.forEach((optionOrGroup) => {
        if (isGroup(optionOrGroup)) {
          flatOptions = flatOptions.concat(optionOrGroup.options);
        } else {
          flatOptions.push(optionOrGroup);
        }
      });
      return flatOptions;
    });
    const handleFocus = (e) => {
      toggleFocused();
      emits("focus", e);
    };
    const handleBlur = (e) => {
      toggleFocused();
      emits("blur", e);
    };
    const handleChange = (e) => {
      const target = e.target;
      model.value = target.value;
      emits("change", target.value, `${id.value}`);
    };
    const getOptionAttrs = (option) => {
      const { value, label, prefix: _prefix, key, ...rest } = option;
      return { ...rest };
    };
    function isString(option) {
      return typeof option === "string";
    }
    function isGroup(option) {
      return typeof option === "object" && "options" in option && option.options != null;
    }
    function normalizeStringOption(option) {
      return {
        label: option,
        value: option
      };
    }
    function normalizeOption(option) {
      if (isString(option)) {
        return normalizeStringOption(option);
      } else if (isGroup(option)) {
        const { title, options } = option;
        return {
          title,
          options: options.map((option2) => {
            return isString(option2) ? normalizeStringOption(option2) : option2;
          })
        };
      }
      return option;
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1), {
        id: `${id.value}`,
        error: _ctx.error,
        action: _ctx.labelAction,
        "label-hidden": labelHidden.value,
        "required-indicator": _ctx.requiredIndicator,
        disabled: _ctx.disabled
      }, createSlots({
        default: withCtx(() => [
          createElementVNode("div", {
            class: normalizeClass(className.value)
          }, [
            createElementVNode("select", {
              id: `${id.value}`,
              name: _ctx.name,
              value: model.value,
              class: normalizeClass(unref(styles).Input),
              disabled: _ctx.disabled,
              "aria-invalid": Boolean(_ctx.error),
              "aria-describedby": ariaDescribedBy.value,
              "aria-required": _ctx.requiredIndicator,
              onFocus: handleFocus,
              onBlur: handleBlur,
              onChange: handleChange
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(optionsMarkup.value, (optOrGroup) => {
                return openBlock(), createElementBlock(Fragment, null, [
                  isGroup(optOrGroup) ? (openBlock(), createElementBlock("optgroup", {
                    label: optOrGroup.title,
                    key: optOrGroup.title
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(optOrGroup.options, (option) => {
                      return openBlock(), createElementBlock("option", mergeProps({
                        key: option.key || option.value,
                        value: option.value,
                        disabled: option.disabled,
                        ref_for: true
                      }, getOptionAttrs(option)), toDisplayString(option.label), 17, _hoisted_3);
                    }), 128))
                  ], 8, _hoisted_2)) : (openBlock(), createElementBlock("option", mergeProps({
                    key: optOrGroup.key || optOrGroup.value,
                    value: optOrGroup.value,
                    disabled: optOrGroup.disabled,
                    ref_for: true
                  }, getOptionAttrs(optOrGroup)), toDisplayString(optOrGroup.label), 17, _hoisted_4))
                ], 64);
              }), 256))
            ], 42, _hoisted_1),
            createElementVNode("div", {
              class: normalizeClass(unref(styles).Content),
              "aria-hidden": "",
              "aria-disabled": _ctx.disabled
            }, [
              _ctx.labelInline ? (openBlock(), createBlock(unref(_sfc_main$2), {
                key: 0,
                "padding-inline-end": "100"
              }, {
                default: withCtx(() => [
                  createVNode(unref(_sfc_main$3), {
                    as: "span",
                    variant: "bodyMd",
                    tone: _ctx.tone && _ctx.tone === "magic" && !unref(focused) ? "magic-subdued" : "subdued",
                    truncate: ""
                  }, {
                    default: withCtx(() => [
                      slots.label ? renderSlot(_ctx.$slots, "label", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createTextVNode(toDisplayString(props.label), 1)
                      ], 64))
                    ]),
                    _: 3
                  }, 8, ["tone"])
                ]),
                _: 3
              })) : createCommentVNode("", true),
              selectedOption.value.prefix ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(styles).Prefix)
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(selectedOption.value.prefix)))
              ], 2)) : createCommentVNode("", true),
              createElementVNode("span", {
                class: normalizeClass(unref(styles).SelectedOption)
              }, toDisplayString(selectedOption.value.label), 3),
              createElementVNode("span", {
                class: normalizeClass(unref(styles).Icon)
              }, [
                createVNode(unref(_sfc_main$4), { source: unref(SelectIcon) }, null, 8, ["source"])
              ], 2)
            ], 10, _hoisted_5),
            createElementVNode("div", {
              class: normalizeClass(unref(styles).Backdrop)
            }, null, 2)
          ], 2)
        ]),
        _: 2
      }, [
        hasLabel.value ? {
          name: "label",
          fn: withCtx(() => [
            slots.label ? renderSlot(_ctx.$slots, "label", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(props.label), 1)
            ], 64))
          ]),
          key: "0"
        } : void 0,
        hasHelpText.value ? {
          name: "helpText",
          fn: withCtx(() => [
            slots.helpText ? renderSlot(_ctx.$slots, "helpText", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(props.helpText), 1)
            ], 64))
          ]),
          key: "1"
        } : void 0
      ]), 1032, ["id", "error", "action", "label-hidden", "required-indicator", "disabled"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Select.vue_vue_type_script_setup_true_lang.js.map
